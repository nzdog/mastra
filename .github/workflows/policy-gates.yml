name: Policy Gates - Memory Layer Spec

on:
  push:
    branches:
      - feature/memory-layer-spec
      - feature/**
  pull_request:
    branches:
      - main
      - master
      - feature/memory-layer-spec

jobs:
  policy-gates:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: lichen_memory_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      # PostgreSQL connection env vars for tests
      PGHOST: localhost
      PGPORT: 5432
      PGDATABASE: lichen_memory_test
      PGUSER: postgres
      PGPASSWORD: postgres

      # Phase 3.2: Ledger configuration for CI
      LEDGER_ENABLED: "false"
      LEDGER_OPTIONAL: "true"

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # Phase 0 - Foundations Gates
      - name: 'Gate: ADR 0001 exists'
        run: test -f docs/adrs/0001-memory-layer-architecture.md

      - name: 'Gate: Spec index exists'
        run: test -f docs/specs/README.md

      - name: 'Gate: /readyz contract exists'
        run: test -f src/memory-layer/api/health.ts

      - name: 'Gate: Audit emitter stub exists'
        run: test -f src/memory-layer/governance/audit-emitter.ts

      # Lint Gates
      - name: 'Gate: TypeScript lint'
        run: npm run lint
        continue-on-error: false

      # Build Gate
      - name: 'Gate: TypeScript build'
        run: npm run build
        continue-on-error: false

      # Test Gates
      - name: 'Gate: Unit tests'
        run: npm test
        continue-on-error: true  # Tests optional in Phase 0

      # Audit Stub Validation
      - name: 'Gate: Audit emitter stub validation'
        run: |
          # Verify audit emitter has required exports
          grep -q "export class AuditEmitter" src/memory-layer/governance/audit-emitter.ts
          grep -q "export function getAuditEmitter" src/memory-layer/governance/audit-emitter.ts
          echo "✅ Audit emitter stub validation passed"

      - name: 'Gate: Health endpoint validation'
        run: |
          # Verify health endpoint has required exports
          grep -q "export async function healthCheck" src/memory-layer/api/health.ts
          grep -q "export interface HealthCheckResponse" src/memory-layer/api/health.ts
          echo "✅ Health endpoint validation passed"

      # Documentation Gates
      - name: 'Gate: ADR completeness'
        run: |
          # Verify ADR has required sections
          grep -q "## Context" docs/adrs/0001-memory-layer-architecture.md
          grep -q "## Decision" docs/adrs/0001-memory-layer-architecture.md
          grep -q "## Consequences" docs/adrs/0001-memory-layer-architecture.md
          echo "✅ ADR completeness validated"

      - name: 'Gate: Spec index completeness'
        run: |
          # Verify spec index tracks all phases
          grep -q "Phase 0" docs/specs/README.md
          grep -q "Phase 1" docs/specs/README.md
          grep -q "Phase 2" docs/specs/README.md
          grep -q "Phase 3" docs/specs/README.md
          grep -q "Phase 4" docs/specs/README.md
          grep -q "Phase 5" docs/specs/README.md
          echo "✅ Spec index completeness validated"

      # Security Gates
      - name: 'Gate: No hardcoded secrets'
        run: |
          # Basic check for common secret patterns
          ! grep -r "sk-ant-" src/ || (echo "❌ Potential API key detected"; exit 1)
          ! grep -r "password.*=" src/ || (echo "⚠️ Potential password detected"; exit 0)
          echo "✅ No obvious hardcoded secrets found"

      # Phase 1.1 - Audit Hardening Gates
      - name: 'Gate: Schema validation (Phase 1.1)'
        run: |
          npm run test:schema-validation
          echo "✅ Schema validation passed"

      - name: 'Gate: RFC-8785 Canonical JSON (Phase 1.1)'
        run: |
          npm run test:canonical-json
          echo "✅ Canonical JSON determinism verified"

      - name: 'Gate: No PII in audit logs (Phase 1.1)'
        run: |
          # Check for common PII patterns in ledger files
          if [ -d ".ledger/" ]; then
            ! grep -r "email.*@" .ledger/ || (echo "❌ Potential PII detected in ledger"; exit 1)
            ! grep -r "ssn.*[0-9]" .ledger/ || (echo "❌ Potential PII detected in ledger"; exit 1)
            echo "✅ No PII detected in audit logs"
          else
            echo "⏩ No ledger directory found (skipping PII check)"
          fi

      # Phase 1.2 - Metrics & Verification
      - name: 'Gate: Metrics endpoint check'
        run: |
          SKIP_API_KEY_CHECK=true npm run server &
          SERVER_PID=$!
          sleep 5
          curl -sf http://localhost:3000/metrics | grep -q "audit_events_total" || (echo "❌ Metrics endpoint failed"; kill $SERVER_PID; exit 1)
          kill $SERVER_PID
          echo "✅ Metrics endpoint operational"

      # Phase 1.2 - CORS Hardening & Verification
      - name: 'Gate: CORS configuration validation'
        run: |
          # Start server with test CORS config
          SKIP_API_KEY_CHECK=true \
          CORS_ALLOWED_ORIGINS="http://localhost:3000,http://localhost:5173" \
          CORS_ALLOW_CREDENTIALS="false" \
          npm run server &
          SERVER_PID=$!

          # Wait for server to be ready (with retries) - Phase 3.2: Use /readyz
          echo "⏳ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "✅ Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Server failed to start after 30 attempts"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          # Test 1: Valid origin receives CORS headers
          echo "🔍 Test 1: Valid origin receives CORS headers"
          RESPONSE=$(curl -sf -H "Origin: http://localhost:3000" -i http://localhost:3000/readyz)
          echo "$RESPONSE" | grep -qi "access-control-allow-origin: http://localhost:3000" || (echo "❌ Valid origin CORS failed"; kill $SERVER_PID; exit 1)

          # Test 2: Invalid origin is rejected (no CORS headers)
          echo "🔍 Test 2: Invalid origin is rejected (no CORS headers)"
          RESPONSE_INVALID=$(curl -sf -H "Origin: https://evil.com" -i http://localhost:3000/readyz)
          echo "$RESPONSE_INVALID" | grep -qi "access-control-allow-origin" && (echo "❌ Invalid origin NOT rejected"; kill $SERVER_PID; exit 1) || true

          # Test 3: Preflight OPTIONS works
          echo "🔍 Test 3: Preflight OPTIONS request works"
          curl -sf -X OPTIONS -H "Origin: http://localhost:3000" -H "Access-Control-Request-Method: GET" -i http://localhost:3000/readyz | grep -qi "access-control-allow-origin" || (echo "❌ Preflight failed"; kill $SERVER_PID; exit 1)

          # Test 4: Security headers present
          echo "🔍 Test 4: Security headers present"
          curl -sf -i http://localhost:3000/readyz | grep -qi "referrer-policy: no-referrer" || (echo "❌ Referrer-Policy missing"; kill $SERVER_PID; exit 1)
          curl -sf -i http://localhost:3000/readyz | grep -qi "x-content-type-options: nosniff" || (echo "❌ X-Content-Type-Options missing"; kill $SERVER_PID; exit 1)
          curl -sf -i http://localhost:3000/readyz | grep -qi "permissions-policy" || (echo "❌ Permissions-Policy missing"; kill $SERVER_PID; exit 1)

          # Test 5: CORS metrics in /metrics endpoint
          echo "🔍 Test 5: CORS metrics in /metrics endpoint"
          curl -sf http://localhost:3000/metrics | grep -q "cors_preflight_total" || (echo "❌ CORS metrics missing"; kill $SERVER_PID; exit 1)
          curl -sf http://localhost:3000/metrics | grep -q "cors_reject_total" || (echo "❌ CORS metrics missing"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "✅ CORS configuration validation passed"

      # Phase 2: Memory Layer Tests
      - name: 'Gate: Phase 2 smoke test'
        run: |
          npm run test:phase-2-smoke
          echo "✅ Phase 2 smoke test passed"

      - name: 'Gate: Memory operations test'
        run: |
          npm run test:memory-operations
          echo "✅ Memory operations test passed"

      - name: 'Gate: Memory middleware test'
        run: |
          npm run test:memory-middleware
          echo "✅ Memory middleware test passed"

      - name: 'Gate: Memory storage test'
        run: |
          npm run test:memory-storage
          echo "✅ Memory storage test passed"

      - name: 'Gate: No PII in logs (Phase 2)'
        run: |
          # Check for PII patterns in test output and ledger
          if [ -d ".ledger/" ]; then
            ! grep -r "email.*@" .ledger/ || (echo "❌ Potential PII detected in ledger"; exit 1)
            ! grep -r "ssn.*[0-9]" .ledger/ || (echo "❌ Potential PII detected in ledger"; exit 1)
            echo "✅ No PII detected in audit logs"
          else
            echo "⏩ No ledger directory found (skipping PII check)"
          fi

      - name: 'Gate: Metrics instrumentation (Phase 2)'
        run: |
          SKIP_API_KEY_CHECK=true npm run server &
          SERVER_PID=$!

          # Wait for server to be ready - Phase 3.2: Use /readyz
          echo "⏳ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "✅ Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          # Check for Phase 2 memory metrics
          METRICS=$(curl -sf http://localhost:3000/metrics)
          echo "$METRICS" | grep -q "memory_operation_duration_seconds" || (echo "❌ Missing memory_operation_duration_seconds metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "memory_operation_total" || (echo "❌ Missing memory_operation_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "memory_store_records_total" || (echo "❌ Missing memory_store_records_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "memory_recall_records_total" || (echo "❌ Missing memory_recall_records_total metric"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "✅ Memory metrics instrumentation verified"

      - name: 'Gate: Error envelope compliance (Phase 2)'
        run: |
          SKIP_API_KEY_CHECK=true npm run server &
          SERVER_PID=$!

          # Wait for server - Phase 3.2: Use /readyz
          echo "⏳ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "✅ Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          # Test 1: 401 Unauthorized error envelope
          echo "🔍 Test 1: 401 error envelope"
          RESPONSE_401=$(curl -s -i -X POST http://localhost:3000/v1/personal/store \
            -H "Content-Type: application/json" \
            -d '{"content":{"type":"text","data":"test"}}' || true)

          echo "$RESPONSE_401" | grep -qi "HTTP/1.1 401" || (echo "❌ Expected 401 status"; kill $SERVER_PID; exit 1)

          BODY_401=$(echo "$RESPONSE_401" | sed -n '/^{/,$p')
          echo "$BODY_401" | grep -q '"code":"UNAUTHORIZED"' || (echo "❌ Missing UNAUTHORIZED code"; kill $SERVER_PID; exit 1)
          echo "$BODY_401" | grep -q '"timestamp"' || (echo "❌ Missing timestamp"; kill $SERVER_PID; exit 1)
          echo "$BODY_401" | grep -q '"path"' || (echo "❌ Missing path"; kill $SERVER_PID; exit 1)

          # Test 2: 400 Validation error envelope
          echo "🔍 Test 2: 400 error envelope"
          RESPONSE_400=$(curl -s -i -X POST http://localhost:3000/v1/personal/store \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer test_token_12345678" \
            -d '{"content":{"type":"text","data":"test"}}' || true)

          echo "$RESPONSE_400" | grep -qi "HTTP/1.1 400" || (echo "❌ Expected 400 status"; kill $SERVER_PID; exit 1)

          BODY_400=$(echo "$RESPONSE_400" | sed -n '/^{/,$p')
          echo "$BODY_400" | grep -q '"code":"VALIDATION_ERROR"' || (echo "❌ Missing VALIDATION_ERROR code"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "✅ Error envelope compliance verified"

      - name: 'Gate: Consent family enforcement (Phase 2)'
        run: |
          SKIP_API_KEY_CHECK=true npm run server &
          SERVER_PID=$!

          # Wait for server - Phase 3.2: Use /readyz
          echo "⏳ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "✅ Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          # Test: Cohort recall should return 403
          echo "🔍 Testing cohort recall forbidden (403)"
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer test_user_12345678" \
            http://localhost:3000/v1/cohort/recall?user_id=test_user)

          if [ "$RESPONSE" != "403" ]; then
            echo "❌ Expected 403 for cohort recall, got $RESPONSE"
            kill $SERVER_PID
            exit 1
          fi

          # Test: Population recall should return 403
          echo "🔍 Testing population recall forbidden (403)"
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer test_user_12345678" \
            http://localhost:3000/v1/population/recall?user_id=test_user)

          if [ "$RESPONSE" != "403" ]; then
            echo "❌ Expected 403 for population recall, got $RESPONSE"
            kill $SERVER_PID
            exit 1
          fi

          # Test: Population forget should return 403
          echo "🔍 Testing population forget forbidden (403)"
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -X DELETE \
            -H "Authorization: Bearer test_user_12345678" \
            http://localhost:3000/v1/population/forget?user_id=test_user)

          if [ "$RESPONSE" != "403" ]; then
            echo "❌ Expected 403 for population forget, got $RESPONSE"
            kill $SERVER_PID
            exit 1
          fi

          kill $SERVER_PID
          echo "✅ Consent family enforcement verified"

      - name: 'Gate: PII Denylist Validation (Phase 2 Privacy Invariant)'
        run: |
          echo "🔍 Checking for raw PII patterns in code..."

          # Check for email patterns in actual code (not comments/strings)
          if grep -rn '@[a-zA-Z0-9.-]\+\.\(com\|org\|net\)' src/memory-layer/api/ test/*.test.ts | \
             grep -v 'example\.com' | grep -v 'test@example' | \
             grep -v '^\s*//' | grep -v '^\s*\*' | grep -v 'DENYLIST' | \
             grep -v 'description:' | grep -v 'comment:'; then
            echo "❌ FAIL: Email-like patterns found in code (possible PII leak)"
            echo "  Ensure all identifiers use hashed_pseudonym with hashed format"
            exit 1
          fi

          # Check for SSN patterns
          if grep -rn '[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}' src/memory-layer/api/ test/*.test.ts | \
             grep -v '^\s*//' | grep -v 'DENYLIST' | grep -v 'pattern:' | grep -v 'example'; then
            echo "❌ FAIL: SSN-like patterns found in code"
            exit 1
          fi

          # Verify hashed_pseudonym is used (not user_id with raw values)
          if grep -rn 'user_id.*:.*@' src/memory-layer/ test/ --include="*.ts" | \
             grep -v '^\s*//' | grep -v 'Old field' | grep -v 'deprecated'; then
            echo "❌ FAIL: user_id field appears to contain email-like values"
            echo "  All identifiers must use hashed_pseudonym with hashed format"
            exit 1
          fi

          echo "✅ No raw PII patterns detected in code"

      - name: 'Gate: No deprecated user_id field (Phase 2 Privacy Invariant)'
        run: |
          echo "🔍 Checking for deprecated user_id references..."

          # Check for user_id in src, openapi, and docs (excluding comments)
          if git grep -n "user_id" -- src openapi docs | grep .; then
            echo "❌ FAIL: Found deprecated user_id references"
            echo "  All references must use hashed_pseudonym instead"
            echo "  Run: git grep -n 'user_id' -- src openapi docs"
            exit 1
          else
            echo "✅ No deprecated user_id references found"
          fi

      # Phase 3 Week 2: Auth, RBAC, Rate Limiting Gates
      - name: 'Gate: Auth provider NOT mock in production (Phase 3)'
        run: |
          echo "🔍 Checking AUTH_PROVIDER configuration..."

          # On main branch, fail if AUTH_PROVIDER=mock
          if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
            if grep -q "AUTH_PROVIDER=mock" .env* 2>/dev/null; then
              echo "❌ FAIL: AUTH_PROVIDER=mock detected on production branch"
              echo "  Production must use AUTH_PROVIDER=jwks with valid JWKS_URL"
              exit 1
            fi
          fi

          echo "✅ Auth provider configuration check passed"

      - name: 'Gate: Rate limiting configured on main branches (Phase 3)'
        run: |
          echo "🔍 Checking rate limiting configuration..."

          # On main branch, warn if rate limiting disabled
          if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
            if grep -q "RATE_LIMIT_ENABLED=false" .env* 2>/dev/null; then
              echo "⚠️ WARNING: RATE_LIMIT_ENABLED=false on production branch"
              echo "  Consider enabling rate limiting for production"
              # Not failing - just warning
            fi
          fi

          echo "✅ Rate limiting configuration check passed"

      - name: 'Gate: Auth verifier tests (Phase 3 Week 2)'
        run: |
          npm run test -- auth-verifier.test.ts
          echo "✅ Auth verifier tests passed"

      - name: 'Gate: Access control tests (Phase 3 Week 2)'
        run: |
          npm run test -- access-control.test.ts
          echo "✅ Access control tests passed"

      - name: 'Gate: Pseudonym rotation tests (Phase 3 Week 2)'
        run: |
          npm run test -- pseudonym-rotation.test.ts
          echo "✅ Pseudonym rotation tests passed"

      - name: 'Gate: No hardcoded salts in production (Phase 3)'
        run: |
          echo "🔍 Checking for default pseudonym salt..."

          # Check if default salt is still in use
          if grep -r "default-dev-salt-change-in-prod" src/ --include="*.ts"; then
            echo "⚠️ WARNING: Default pseudonym salt found in source code"
            echo "  Ensure PSEUDONYM_PERIOD_SALT is set via environment variable in production"
            # Not failing - salt should come from env, not code
          fi

          echo "✅ Salt configuration check passed"

      # Phase 3 Week 3: Encryption & Postgres Hardening Gates
      - name: 'Gate: Encryption roundtrip tests (Phase 3 Week 3)'
        run: |
          npm run test -- encryption-roundtrip.test.ts
          echo "✅ Encryption roundtrip tests passed"

      - name: 'Gate: Postgres store tests (Phase 3 Week 3)'
        run: |
          npm run test -- postgres-store.test.ts
          echo "✅ Postgres store tests passed"

      - name: 'Gate: Encryption metrics available (Phase 3 Week 3)'
        run: |
          SKIP_API_KEY_CHECK=true ENCRYPTION_ENABLED=true npm run server &
          SERVER_PID=$!

          # Wait for server
          echo "⏳ Waiting for server to start..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "✅ Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          sleep 3

          # Check for encryption metrics
          METRICS=$(curl -sf http://localhost:3000/metrics)
          echo "$METRICS" | grep -q "crypto_encrypt_failures_total" || (echo "❌ Missing crypto_encrypt_failures_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "crypto_decrypt_failures_total" || (echo "❌ Missing crypto_decrypt_failures_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "crypto_ops_duration_ms" || (echo "❌ Missing crypto_ops_duration_ms metric"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "✅ Encryption metrics verified"

      - name: 'Gate: Partitioning migration exists (Phase 3 Week 3)'
        run: |
          test -f migrations/002_partitions.sql
          grep -q "PARTITION BY RANGE (created_at)" migrations/002_partitions.sql
          grep -q "create_monthly_partition" migrations/002_partitions.sql
          echo "✅ Partitioning migration validated"

      - name: 'Gate: TTL sweep job exists (Phase 3 Week 3)'
        run: |
          test -f src/memory-layer/jobs/ttl-sweep.ts
          grep -q "class TTLSweepJob" src/memory-layer/jobs/ttl-sweep.ts
          grep -q "ttl_sweep_records_total" src/memory-layer/jobs/ttl-sweep.ts
          echo "✅ TTL sweep job validated"

      - name: 'Gate: Dual-write tests (Phase 3 Week 3)'
        run: |
          npm run test -- dual-write.test.ts
          echo "✅ Dual-write tests passed"

      - name: 'Gate: Backfill tests (Phase 3 Week 3)'
        run: |
          npm run test -- backfill.test.ts
          echo "✅ Backfill tests passed"

      - name: 'Gate: Dual-write adapter selector support (Phase 3 Week 3)'
        run: |
          test -f src/memory-layer/storage/dual-store.ts
          grep -q "class DualStore" src/memory-layer/storage/dual-store.ts
          grep -q "case 'dual-write'" src/memory-layer/storage/adapter-selector.ts
          grep -q "getDualStore" src/memory-layer/storage/adapter-selector.ts
          echo "✅ Dual-write adapter selector validated"

      - name: 'Gate: Backfill script exists (Phase 3 Week 3)'
        run: |
          test -f scripts/backfill-to-postgres.ts
          grep -q "backfillToPostgres" scripts/backfill-to-postgres.ts
          grep -q "verifyBackfill" scripts/backfill-to-postgres.ts
          echo "✅ Backfill script validated"

      - name: 'Gate: Dual-write metrics available (Phase 3 Week 3)'
        run: |
          SKIP_API_KEY_CHECK=true PERSISTENCE=dual-write DUAL_WRITE_ENABLED=true npm run server &
          SERVER_PID=$!

          # Wait for server
          echo "⏳ Waiting for server to start..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "✅ Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          sleep 3

          # Check for dual-write metrics
          METRICS=$(curl -sf http://localhost:3000/metrics)
          echo "$METRICS" | grep -q "dual_write_records_total" || (echo "❌ Missing dual_write_records_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "dual_write_failures_total" || (echo "❌ Missing dual_write_failures_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "backfill_records_total" || (echo "❌ Missing backfill_records_total metric"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "✅ Dual-write metrics verified"

      # Phase 3 Week 3: Migration Safety Gates
      - name: 'Gate: No destructive SQL in production migrations (Phase 3 Week 3)'
        run: |
          echo "🔍 Checking for destructive SQL in production migrations..."

          # HIGH-6: Run on ALL branches to prevent accidental destructive SQL
          if git grep -n -i -E "DROP[[:space:]]+TABLE" -- migrations/*.sql | grep -v "_dev.sql"; then
            echo "❌ FAIL: Destructive SQL detected in production migrations"
            echo "  DROP TABLE statements must only be in files ending with _dev.sql"
            echo "  Production migrations must be non-destructive and idempotent"
            exit 1
          fi

          echo "✅ No destructive SQL in production migrations"

      - name: 'Gate: Safe migration banner validation (Phase 3 Week 3)'
        run: |
          echo "🔍 Validating safe migration banner..."

          # Verify 002_partitions.sql contains SAFE PRODUCTION MIGRATION banner
          if ! grep -q "SAFE PRODUCTION MIGRATION" migrations/002_partitions.sql; then
            echo "❌ FAIL: migrations/002_partitions.sql missing 'SAFE PRODUCTION MIGRATION' banner"
            echo "  Ensure correct migration file is being used"
            exit 1
          fi

          # Verify it uses IF NOT EXISTS patterns
          if ! grep -q "IF NOT EXISTS" migrations/002_partitions.sql; then
            echo "❌ FAIL: migrations/002_partitions.sql missing IF NOT EXISTS patterns"
            echo "  Production migrations must be idempotent"
            exit 1
          fi

          # Verify helper function exists
          if ! grep -q "create_monthly_partition" migrations/002_partitions.sql; then
            echo "❌ FAIL: migrations/002_partitions.sql missing partition helper function"
            exit 1
          fi

          echo "✅ Safe migration banner validated"

      - name: 'Gate: Migration runbook exists (Phase 3 Week 3)'
        run: |
          test -f docs/runbooks/partitioning-migrations.md
          grep -q "Production-Safe Migration" docs/runbooks/partitioning-migrations.md
          grep -q "Dev-Only Migration" docs/runbooks/partitioning-migrations.md
          echo "✅ Migration runbook validated"

      # Branch Protection Validation
      - name: 'Gate: Branch protection check'
        if: github.ref == 'refs/heads/feature/memory-layer-spec'
        run: |
          echo "✅ Running on protected branch feature/memory-layer-spec"
          echo "This branch should be protected with:"
          echo "  - No force pushes"
          echo "  - No deletions"
          echo "  - Required status checks (this workflow)"

  audit-compliance:
    runs-on: ubuntu-latest
    needs: policy-gates
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: 'Audit: Verify audit emitter initialization'
        run: |
          echo "import { getAuditEmitter } from './dist/memory-layer/governance/audit-emitter.js';" > test-audit.mjs
          echo "const emitter = getAuditEmitter();" >> test-audit.mjs
          echo "console.log('Audit emitter initialized:', emitter.getLedgerHeight() === 0);" >> test-audit.mjs
          node test-audit.mjs
          rm test-audit.mjs

      - name: 'Audit: Generate compliance report'
        run: |
          echo "## Compliance Report - $(date)" > compliance-report.md
          echo "" >> compliance-report.md
          echo "### Phase 0 - Foundations" >> compliance-report.md
          echo "- [x] Long-lived branch created and protected" >> compliance-report.md
          echo "- [x] ADR 0001 documented" >> compliance-report.md
          echo "- [x] Spec index created" >> compliance-report.md
          echo "- [x] /readyz contract seeded" >> compliance-report.md
          echo "- [x] Audit emitter stub implemented" >> compliance-report.md
          echo "- [x] CI policy gates configured" >> compliance-report.md
          echo "" >> compliance-report.md
          echo "### Audit Status" >> compliance-report.md
          echo "- Audit emitter: Stub mode (Phase 1 will add cryptographic signatures)" >> compliance-report.md
          echo "- Health endpoint: Operational" >> compliance-report.md
          echo "- Branch protection: Enabled" >> compliance-report.md
          cat compliance-report.md

      - name: Upload compliance report
        uses: actions/upload-artifact@v4
        with:
          name: compliance-report
          path: compliance-report.md
