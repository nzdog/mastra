name: Policy Gates - Memory Layer Spec

on:
  push:
    branches:
      - feature/memory-layer-spec
      - feature/**
  pull_request:
    branches:
      - main
      - master
      - feature/memory-layer-spec

jobs:
  policy-gates:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: lichen_memory_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      # PostgreSQL connection env vars for tests
      PGHOST: localhost
      PGPORT: 5432
      PGDATABASE: lichen_memory_test
      PGUSER: postgres
      PGPASSWORD: postgres

      # Phase 3.2: Ledger configuration for CI
      LEDGER_ENABLED: "false"
      LEDGER_OPTIONAL: "true"

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      # Phase 0 - Foundations Gates
      - name: 'Gate: ADR 0001 exists'
        run: test -f docs/adrs/0001-memory-layer-architecture.md

      - name: 'Gate: Spec index exists'
        run: test -f docs/specs/README.md

      - name: 'Gate: /readyz contract exists'
        run: test -f src/memory-layer/api/health.ts

      - name: 'Gate: Audit emitter stub exists'
        run: test -f src/memory-layer/governance/audit-emitter.ts

      # Lint Gates
      - name: 'Gate: TypeScript lint'
        run: npm run lint
        continue-on-error: false

      # Build Gate
      - name: 'Gate: TypeScript build'
        run: npm run build
        continue-on-error: false

      # Test Gates
      - name: 'Gate: Unit tests'
        run: npm test
        continue-on-error: true  # Tests optional in Phase 0

      # Audit Stub Validation
      - name: 'Gate: Audit emitter stub validation'
        run: |
          # Verify audit emitter has required exports
          grep -q "export class AuditEmitter" src/memory-layer/governance/audit-emitter.ts
          grep -q "export function getAuditEmitter" src/memory-layer/governance/audit-emitter.ts
          echo "âœ… Audit emitter stub validation passed"

      - name: 'Gate: Health endpoint validation'
        run: |
          # Verify health endpoint has required exports
          grep -q "export async function healthCheck" src/memory-layer/api/health.ts
          grep -q "export interface HealthCheckResponse" src/memory-layer/api/health.ts
          echo "âœ… Health endpoint validation passed"

      # Documentation Gates
      - name: 'Gate: ADR completeness'
        run: |
          # Verify ADR has required sections
          grep -q "## Context" docs/adrs/0001-memory-layer-architecture.md
          grep -q "## Decision" docs/adrs/0001-memory-layer-architecture.md
          grep -q "## Consequences" docs/adrs/0001-memory-layer-architecture.md
          echo "âœ… ADR completeness validated"

      - name: 'Gate: Spec index completeness'
        run: |
          # Verify spec index tracks all phases
          grep -q "Phase 0" docs/specs/README.md
          grep -q "Phase 1" docs/specs/README.md
          grep -q "Phase 2" docs/specs/README.md
          grep -q "Phase 3" docs/specs/README.md
          grep -q "Phase 4" docs/specs/README.md
          grep -q "Phase 5" docs/specs/README.md
          echo "âœ… Spec index completeness validated"

      # Security Gates
      - name: 'Gate: No hardcoded secrets'
        run: |
          # Basic check for common secret patterns
          ! grep -r "sk-ant-" src/ || (echo "âŒ Potential API key detected"; exit 1)
          ! grep -r "password.*=" src/ || (echo "âš ï¸ Potential password detected"; exit 0)
          echo "âœ… No obvious hardcoded secrets found"

      # Phase 1.1 - Audit Hardening Gates
      - name: 'Gate: Schema validation (Phase 1.1)'
        run: |
          npm run test:schema-validation
          echo "âœ… Schema validation passed"

      - name: 'Gate: RFC-8785 Canonical JSON (Phase 1.1)'
        run: |
          npm run test:canonical-json
          echo "âœ… Canonical JSON determinism verified"

      - name: 'Gate: No PII in audit logs (Phase 1.1)'
        run: |
          # Check for common PII patterns in ledger files
          if [ -d ".ledger/" ]; then
            ! grep -r "email.*@" .ledger/ || (echo "âŒ Potential PII detected in ledger"; exit 1)
            ! grep -r "ssn.*[0-9]" .ledger/ || (echo "âŒ Potential PII detected in ledger"; exit 1)
            echo "âœ… No PII detected in audit logs"
          else
            echo "â© No ledger directory found (skipping PII check)"
          fi

      # Phase 1.2 - Metrics & Verification
      - name: 'Gate: Metrics endpoint check'
        run: |
          SKIP_API_KEY_CHECK=true npm run server &
          SERVER_PID=$!
          sleep 5
          curl -sf http://localhost:3000/metrics | grep -q "audit_events_total" || (echo "âŒ Metrics endpoint failed"; kill $SERVER_PID; exit 1)
          kill $SERVER_PID
          echo "âœ… Metrics endpoint operational"

      # Phase 1.2 - CORS Hardening & Verification
      - name: 'Gate: CORS configuration validation'
        run: |
          # Start server with test CORS config
          SKIP_API_KEY_CHECK=true \
          CORS_ALLOWED_ORIGINS="http://localhost:3000,http://localhost:5173" \
          CORS_ALLOW_CREDENTIALS="false" \
          npm run server &
          SERVER_PID=$!

          # Wait for server to be ready (with retries) - Phase 3.2: Use /readyz
          echo "â³ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "âœ… Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Server failed to start after 30 attempts"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          # Test 1: Valid origin receives CORS headers
          echo "ðŸ” Test 1: Valid origin receives CORS headers"
          RESPONSE=$(curl -sf -H "Origin: http://localhost:3000" -i http://localhost:3000/readyz)
          echo "$RESPONSE" | grep -qi "access-control-allow-origin: http://localhost:3000" || (echo "âŒ Valid origin CORS failed"; kill $SERVER_PID; exit 1)

          # Test 2: Invalid origin is rejected (no CORS headers)
          echo "ðŸ” Test 2: Invalid origin is rejected (no CORS headers)"
          RESPONSE_INVALID=$(curl -sf -H "Origin: https://evil.com" -i http://localhost:3000/readyz)
          echo "$RESPONSE_INVALID" | grep -qi "access-control-allow-origin" && (echo "âŒ Invalid origin NOT rejected"; kill $SERVER_PID; exit 1) || true

          # Test 3: Preflight OPTIONS works
          echo "ðŸ” Test 3: Preflight OPTIONS request works"
          curl -sf -X OPTIONS -H "Origin: http://localhost:3000" -H "Access-Control-Request-Method: GET" -i http://localhost:3000/readyz | grep -qi "access-control-allow-origin" || (echo "âŒ Preflight failed"; kill $SERVER_PID; exit 1)

          # Test 4: Security headers present
          echo "ðŸ” Test 4: Security headers present"
          curl -sf -i http://localhost:3000/readyz | grep -qi "referrer-policy: no-referrer" || (echo "âŒ Referrer-Policy missing"; kill $SERVER_PID; exit 1)
          curl -sf -i http://localhost:3000/readyz | grep -qi "x-content-type-options: nosniff" || (echo "âŒ X-Content-Type-Options missing"; kill $SERVER_PID; exit 1)
          curl -sf -i http://localhost:3000/readyz | grep -qi "permissions-policy" || (echo "âŒ Permissions-Policy missing"; kill $SERVER_PID; exit 1)

          # Test 5: CORS metrics in /metrics endpoint
          echo "ðŸ” Test 5: CORS metrics in /metrics endpoint"
          curl -sf http://localhost:3000/metrics | grep -q "cors_preflight_total" || (echo "âŒ CORS metrics missing"; kill $SERVER_PID; exit 1)
          curl -sf http://localhost:3000/metrics | grep -q "cors_reject_total" || (echo "âŒ CORS metrics missing"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "âœ… CORS configuration validation passed"

      # Phase 2: Memory Layer Tests
      - name: 'Gate: Phase 2 smoke test'
        run: |
          npm run test:phase-2-smoke
          echo "âœ… Phase 2 smoke test passed"

      - name: 'Gate: Memory operations test'
        run: |
          npm run test:memory-operations
          echo "âœ… Memory operations test passed"

      - name: 'Gate: Memory middleware test'
        run: |
          npm run test:memory-middleware
          echo "âœ… Memory middleware test passed"

      - name: 'Gate: Memory storage test'
        run: |
          npm run test:memory-storage
          echo "âœ… Memory storage test passed"

      - name: 'Gate: No PII in logs (Phase 2)'
        run: |
          # Check for PII patterns in test output and ledger
          if [ -d ".ledger/" ]; then
            ! grep -r "email.*@" .ledger/ || (echo "âŒ Potential PII detected in ledger"; exit 1)
            ! grep -r "ssn.*[0-9]" .ledger/ || (echo "âŒ Potential PII detected in ledger"; exit 1)
            echo "âœ… No PII detected in audit logs"
          else
            echo "â© No ledger directory found (skipping PII check)"
          fi

      - name: 'Gate: Metrics instrumentation (Phase 2)'
        run: |
          SKIP_API_KEY_CHECK=true npm run server &
          SERVER_PID=$!

          # Wait for server to be ready - Phase 3.2: Use /readyz
          echo "â³ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "âœ… Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          # Check for Phase 2 memory metrics
          METRICS=$(curl -sf http://localhost:3000/metrics)
          echo "$METRICS" | grep -q "memory_operation_duration_seconds" || (echo "âŒ Missing memory_operation_duration_seconds metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "memory_operation_total" || (echo "âŒ Missing memory_operation_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "memory_store_records_total" || (echo "âŒ Missing memory_store_records_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "memory_recall_records_total" || (echo "âŒ Missing memory_recall_records_total metric"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "âœ… Memory metrics instrumentation verified"

      - name: 'Gate: Error envelope compliance (Phase 2)'
        run: |
          SKIP_API_KEY_CHECK=true npm run server &
          SERVER_PID=$!

          # Wait for server - Phase 3.2: Use /readyz
          echo "â³ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "âœ… Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          # Test 1: 401 Unauthorized error envelope
          echo "ðŸ” Test 1: 401 error envelope"
          RESPONSE_401=$(curl -s -i -X POST http://localhost:3000/v1/personal/store \
            -H "Content-Type: application/json" \
            -d '{"content":{"type":"text","data":"test"}}' || true)

          echo "$RESPONSE_401" | grep -qi "HTTP/1.1 401" || (echo "âŒ Expected 401 status"; kill $SERVER_PID; exit 1)

          BODY_401=$(echo "$RESPONSE_401" | sed -n '/^{/,$p')
          echo "$BODY_401" | grep -q '"code":"UNAUTHORIZED"' || (echo "âŒ Missing UNAUTHORIZED code"; kill $SERVER_PID; exit 1)
          echo "$BODY_401" | grep -q '"timestamp"' || (echo "âŒ Missing timestamp"; kill $SERVER_PID; exit 1)
          echo "$BODY_401" | grep -q '"path"' || (echo "âŒ Missing path"; kill $SERVER_PID; exit 1)

          # Test 2: 400 Validation error envelope
          echo "ðŸ” Test 2: 400 error envelope"
          RESPONSE_400=$(curl -s -i -X POST http://localhost:3000/v1/personal/store \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer test_token_12345678" \
            -d '{"content":{"type":"text","data":"test"}}' || true)

          echo "$RESPONSE_400" | grep -qi "HTTP/1.1 400" || (echo "âŒ Expected 400 status"; kill $SERVER_PID; exit 1)

          BODY_400=$(echo "$RESPONSE_400" | sed -n '/^{/,$p')
          echo "$BODY_400" | grep -q '"code":"VALIDATION_ERROR"' || (echo "âŒ Missing VALIDATION_ERROR code"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "âœ… Error envelope compliance verified"

      - name: 'Gate: Consent family enforcement (Phase 2)'
        run: |
          SKIP_API_KEY_CHECK=true npm run server &
          SERVER_PID=$!

          # Wait for server - Phase 3.2: Use /readyz
          echo "â³ Waiting for server to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "âœ… Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          # Test: Cohort recall should return 403
          echo "ðŸ” Testing cohort recall forbidden (403)"
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer test_user_12345678" \
            http://localhost:3000/v1/cohort/recall?user_id=test_user)

          if [ "$RESPONSE" != "403" ]; then
            echo "âŒ Expected 403 for cohort recall, got $RESPONSE"
            kill $SERVER_PID
            exit 1
          fi

          # Test: Population recall should return 403
          echo "ðŸ” Testing population recall forbidden (403)"
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer test_user_12345678" \
            http://localhost:3000/v1/population/recall?user_id=test_user)

          if [ "$RESPONSE" != "403" ]; then
            echo "âŒ Expected 403 for population recall, got $RESPONSE"
            kill $SERVER_PID
            exit 1
          fi

          # Test: Population forget should return 403
          echo "ðŸ” Testing population forget forbidden (403)"
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
            -X DELETE \
            -H "Authorization: Bearer test_user_12345678" \
            http://localhost:3000/v1/population/forget?user_id=test_user)

          if [ "$RESPONSE" != "403" ]; then
            echo "âŒ Expected 403 for population forget, got $RESPONSE"
            kill $SERVER_PID
            exit 1
          fi

          kill $SERVER_PID
          echo "âœ… Consent family enforcement verified"

      - name: 'Gate: PII Denylist Validation (Phase 2 Privacy Invariant)'
        run: |
          echo "ðŸ” Checking for raw PII patterns in code..."

          # Check for email patterns in actual code (not comments/strings)
          if grep -rn '@[a-zA-Z0-9.-]\+\.\(com\|org\|net\)' src/memory-layer/api/ test/*.test.ts | \
             grep -v 'example\.com' | grep -v 'test@example' | \
             grep -v '^\s*//' | grep -v '^\s*\*' | grep -v 'DENYLIST' | \
             grep -v 'description:' | grep -v 'comment:'; then
            echo "âŒ FAIL: Email-like patterns found in code (possible PII leak)"
            echo "  Ensure all identifiers use hashed_pseudonym with hashed format"
            exit 1
          fi

          # Check for SSN patterns
          if grep -rn '[0-9]\{3\}-[0-9]\{2\}-[0-9]\{4\}' src/memory-layer/api/ test/*.test.ts | \
             grep -v '^\s*//' | grep -v 'DENYLIST' | grep -v 'pattern:' | grep -v 'example'; then
            echo "âŒ FAIL: SSN-like patterns found in code"
            exit 1
          fi

          # Verify hashed_pseudonym is used (not user_id with raw values)
          if grep -rn 'user_id.*:.*@' src/memory-layer/ test/ --include="*.ts" | \
             grep -v '^\s*//' | grep -v 'Old field' | grep -v 'deprecated'; then
            echo "âŒ FAIL: user_id field appears to contain email-like values"
            echo "  All identifiers must use hashed_pseudonym with hashed format"
            exit 1
          fi

          echo "âœ… No raw PII patterns detected in code"

      - name: 'Gate: No deprecated user_id field (Phase 2 Privacy Invariant)'
        run: |
          echo "ðŸ” Checking for deprecated user_id references..."

          # Check for user_id in src, openapi, and docs (excluding comments)
          if git grep -n "user_id" -- src openapi docs | grep .; then
            echo "âŒ FAIL: Found deprecated user_id references"
            echo "  All references must use hashed_pseudonym instead"
            echo "  Run: git grep -n 'user_id' -- src openapi docs"
            exit 1
          else
            echo "âœ… No deprecated user_id references found"
          fi

      # Phase 3 Week 2: Auth, RBAC, Rate Limiting Gates
      - name: 'Gate: Auth provider NOT mock in production (Phase 3)'
        run: |
          echo "ðŸ” Checking AUTH_PROVIDER configuration..."

          # On main branch, fail if AUTH_PROVIDER=mock
          if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
            if grep -q "AUTH_PROVIDER=mock" .env* 2>/dev/null; then
              echo "âŒ FAIL: AUTH_PROVIDER=mock detected on production branch"
              echo "  Production must use AUTH_PROVIDER=jwks with valid JWKS_URL"
              exit 1
            fi
          fi

          echo "âœ… Auth provider configuration check passed"

      - name: 'Gate: Rate limiting configured on main branches (Phase 3)'
        run: |
          echo "ðŸ” Checking rate limiting configuration..."

          # On main branch, warn if rate limiting disabled
          if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.ref }}" == "refs/heads/master" ]; then
            if grep -q "RATE_LIMIT_ENABLED=false" .env* 2>/dev/null; then
              echo "âš ï¸ WARNING: RATE_LIMIT_ENABLED=false on production branch"
              echo "  Consider enabling rate limiting for production"
              # Not failing - just warning
            fi
          fi

          echo "âœ… Rate limiting configuration check passed"

      - name: 'Gate: Auth verifier tests (Phase 3 Week 2)'
        run: |
          npm run test -- auth-verifier.test.ts
          echo "âœ… Auth verifier tests passed"

      - name: 'Gate: Access control tests (Phase 3 Week 2)'
        run: |
          npm run test -- access-control.test.ts
          echo "âœ… Access control tests passed"

      - name: 'Gate: Pseudonym rotation tests (Phase 3 Week 2)'
        run: |
          npm run test -- pseudonym-rotation.test.ts
          echo "âœ… Pseudonym rotation tests passed"

      - name: 'Gate: No hardcoded salts in production (Phase 3)'
        run: |
          echo "ðŸ” Checking for default pseudonym salt..."

          # Check if default salt is still in use
          if grep -r "default-dev-salt-change-in-prod" src/ --include="*.ts"; then
            echo "âš ï¸ WARNING: Default pseudonym salt found in source code"
            echo "  Ensure PSEUDONYM_PERIOD_SALT is set via environment variable in production"
            # Not failing - salt should come from env, not code
          fi

          echo "âœ… Salt configuration check passed"

      # Phase 3 Week 3: Encryption & Postgres Hardening Gates
      - name: 'Gate: Encryption roundtrip tests (Phase 3 Week 3)'
        run: |
          npm run test -- encryption-roundtrip.test.ts
          echo "âœ… Encryption roundtrip tests passed"

      - name: 'Gate: Postgres store tests (Phase 3 Week 3)'
        run: |
          npm run test -- postgres-store.test.ts
          echo "âœ… Postgres store tests passed"

      - name: 'Gate: Encryption metrics available (Phase 3 Week 3)'
        run: |
          SKIP_API_KEY_CHECK=true ENCRYPTION_ENABLED=true npm run server &
          SERVER_PID=$!

          # Wait for server
          echo "â³ Waiting for server to start..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "âœ… Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          sleep 3

          # Check for encryption metrics
          METRICS=$(curl -sf http://localhost:3000/metrics)
          echo "$METRICS" | grep -q "crypto_encrypt_failures_total" || (echo "âŒ Missing crypto_encrypt_failures_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "crypto_decrypt_failures_total" || (echo "âŒ Missing crypto_decrypt_failures_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "crypto_ops_duration_ms" || (echo "âŒ Missing crypto_ops_duration_ms metric"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "âœ… Encryption metrics verified"

      - name: 'Gate: Partitioning migration exists (Phase 3 Week 3)'
        run: |
          test -f migrations/002_partitions.sql
          grep -q "PARTITION BY RANGE (created_at)" migrations/002_partitions.sql
          grep -q "create_monthly_partition" migrations/002_partitions.sql
          echo "âœ… Partitioning migration validated"

      - name: 'Gate: TTL sweep job exists (Phase 3 Week 3)'
        run: |
          test -f src/memory-layer/jobs/ttl-sweep.ts
          grep -q "class TTLSweepJob" src/memory-layer/jobs/ttl-sweep.ts
          grep -q "ttl_sweep_records_total" src/memory-layer/jobs/ttl-sweep.ts
          echo "âœ… TTL sweep job validated"

      - name: 'Gate: Dual-write tests (Phase 3 Week 3)'
        run: |
          npm run test -- dual-write.test.ts
          echo "âœ… Dual-write tests passed"

      - name: 'Gate: Backfill tests (Phase 3 Week 3)'
        run: |
          npm run test -- backfill.test.ts
          echo "âœ… Backfill tests passed"

      - name: 'Gate: Dual-write adapter selector support (Phase 3 Week 3)'
        run: |
          test -f src/memory-layer/storage/dual-store.ts
          grep -q "class DualStore" src/memory-layer/storage/dual-store.ts
          grep -q "case 'dual-write'" src/memory-layer/storage/adapter-selector.ts
          grep -q "getDualStore" src/memory-layer/storage/adapter-selector.ts
          echo "âœ… Dual-write adapter selector validated"

      - name: 'Gate: Backfill script exists (Phase 3 Week 3)'
        run: |
          test -f scripts/backfill-to-postgres.ts
          grep -q "backfillToPostgres" scripts/backfill-to-postgres.ts
          grep -q "verifyBackfill" scripts/backfill-to-postgres.ts
          echo "âœ… Backfill script validated"

      - name: 'Gate: Dual-write metrics available (Phase 3 Week 3)'
        run: |
          SKIP_API_KEY_CHECK=true PERSISTENCE=dual-write DUAL_WRITE_ENABLED=true npm run server &
          SERVER_PID=$!

          # Wait for server
          echo "â³ Waiting for server to start..."
          for i in {1..30}; do
            if curl -sf http://localhost:3000/readyz > /dev/null 2>&1; then
              echo "âœ… Server ready after $i attempts"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Server failed to start"
              kill $SERVER_PID
              exit 1
            fi
            sleep 1
          done

          sleep 3

          # Check for dual-write metrics
          METRICS=$(curl -sf http://localhost:3000/metrics)
          echo "$METRICS" | grep -q "dual_write_records_total" || (echo "âŒ Missing dual_write_records_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "dual_write_failures_total" || (echo "âŒ Missing dual_write_failures_total metric"; kill $SERVER_PID; exit 1)
          echo "$METRICS" | grep -q "backfill_records_total" || (echo "âŒ Missing backfill_records_total metric"; kill $SERVER_PID; exit 1)

          kill $SERVER_PID
          echo "âœ… Dual-write metrics verified"

      # Phase 3 Week 3: Migration Safety Gates
      - name: 'Gate: No destructive SQL in production migrations (Phase 3 Week 3)'
        run: |
          echo "ðŸ” Checking for destructive SQL in production migrations..."

          # HIGH-6: Run on ALL branches to prevent accidental destructive SQL
          if git grep -n -i -E "DROP[[:space:]]+TABLE" -- migrations/*.sql | grep -v "_dev.sql"; then
            echo "âŒ FAIL: Destructive SQL detected in production migrations"
            echo "  DROP TABLE statements must only be in files ending with _dev.sql"
            echo "  Production migrations must be non-destructive and idempotent"
            exit 1
          fi

          echo "âœ… No destructive SQL in production migrations"

      - name: 'Gate: Safe migration banner validation (Phase 3 Week 3)'
        run: |
          echo "ðŸ” Validating safe migration banner..."

          # Verify 002_partitions.sql contains SAFE PRODUCTION MIGRATION banner
          if ! grep -q "SAFE PRODUCTION MIGRATION" migrations/002_partitions.sql; then
            echo "âŒ FAIL: migrations/002_partitions.sql missing 'SAFE PRODUCTION MIGRATION' banner"
            echo "  Ensure correct migration file is being used"
            exit 1
          fi

          # Verify it uses IF NOT EXISTS patterns
          if ! grep -q "IF NOT EXISTS" migrations/002_partitions.sql; then
            echo "âŒ FAIL: migrations/002_partitions.sql missing IF NOT EXISTS patterns"
            echo "  Production migrations must be idempotent"
            exit 1
          fi

          # Verify helper function exists
          if ! grep -q "create_monthly_partition" migrations/002_partitions.sql; then
            echo "âŒ FAIL: migrations/002_partitions.sql missing partition helper function"
            exit 1
          fi

          echo "âœ… Safe migration banner validated"

      - name: 'Gate: Migration runbook exists (Phase 3 Week 3)'
        run: |
          test -f docs/runbooks/partitioning-migrations.md
          grep -q "Production-Safe Migration" docs/runbooks/partitioning-migrations.md
          grep -q "Dev-Only Migration" docs/runbooks/partitioning-migrations.md
          echo "âœ… Migration runbook validated"

      # Branch Protection Validation
      - name: 'Gate: Branch protection check'
        if: github.ref == 'refs/heads/feature/memory-layer-spec'
        run: |
          echo "âœ… Running on protected branch feature/memory-layer-spec"
          echo "This branch should be protected with:"
          echo "  - No force pushes"
          echo "  - No deletions"
          echo "  - Required status checks (this workflow)"

  audit-compliance:
    runs-on: ubuntu-latest
    needs: policy-gates
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: 'Audit: Verify audit emitter initialization'
        run: |
          echo "import { getAuditEmitter } from './dist/memory-layer/governance/audit-emitter.js';" > test-audit.mjs
          echo "const emitter = getAuditEmitter();" >> test-audit.mjs
          echo "console.log('Audit emitter initialized:', emitter.getLedgerHeight() === 0);" >> test-audit.mjs
          node test-audit.mjs
          rm test-audit.mjs

      - name: 'Audit: Generate compliance report'
        run: |
          echo "## Compliance Report - $(date)" > compliance-report.md
          echo "" >> compliance-report.md
          echo "### Phase 0 - Foundations" >> compliance-report.md
          echo "- [x] Long-lived branch created and protected" >> compliance-report.md
          echo "- [x] ADR 0001 documented" >> compliance-report.md
          echo "- [x] Spec index created" >> compliance-report.md
          echo "- [x] /readyz contract seeded" >> compliance-report.md
          echo "- [x] Audit emitter stub implemented" >> compliance-report.md
          echo "- [x] CI policy gates configured" >> compliance-report.md
          echo "" >> compliance-report.md
          echo "### Audit Status" >> compliance-report.md
          echo "- Audit emitter: Stub mode (Phase 1 will add cryptographic signatures)" >> compliance-report.md
          echo "- Health endpoint: Operational" >> compliance-report.md
          echo "- Branch protection: Enabled" >> compliance-report.md
          cat compliance-report.md

      - name: Upload compliance report
        uses: actions/upload-artifact@v4
        with:
          name: compliance-report
          path: compliance-report.md
