BUILD THE LICHEN COHERENCE ENGINE (NO CODE FROM USER)

You are an expert backend/system architect and engineer.

Your task is to implement the Lichen Protocol Coherence Engine based entirely on the specification contained in my project files (especially SPEC.md, API_EXAMPLES.json, TESTS.md, MVP_SLICE.md).

I will not be writing any code myself. You will design, scaffold, and implement everything, and I will review and run it.

⸻

0. Context: What You’re Building

The Coherence Engine is the real-time stability + momentum layer for the Lichen Protocol. It has two tightly constrained roles:
	1.	Stabilisation (Downward Coherence)
	•	Detect drift (emotional, rhythm, cognitive, field, relational, pressure)
	•	Classify integrity state: STABLE, DRIFT, DISTORTION, PRE_COLLAPSE
	•	Route to the correct protocol or trigger an exit precursor
	•	Emit a one-line stabilisation cue (e.g. “Pause.”)
	2.	Amplification (Upward Coherence)
	•	Detect upward coherence (expansion without distortion)
	•	Safely magnify coherence
	•	Release non-urgent, founder-led momentum
	•	Prevent “positive urgency” and hype
	•	Anchor gains, not speed the founder up

Everything is explicitly defined in the spec.
Your job is to turn that spec into a clean, testable, production-ready codebase.

⸻

1. Non-Negotiable Architectural Constraints

When you implement, you must uphold these rules literally:
	1.	Present-state only classification
	•	No prediction, no trend analysis, no forecasting.
	•	integrity_state is determined entirely from the current founder_state input.
	2.	Memory is descriptive, not predictive
	•	Memory is an event log, not a model.
	•	It must not influence classification via probability, trend, or “likely outcomes”.
	3.	Output schema lock for the Coherence Engine
Allowed outputs (downward + upward) are exactly what the spec describes:
	•	State reflection (present only)
	•	Integrity classification
	•	Protocol route or exit precursor flag
	•	One-line stabilisation cue
	•	Upward coherence block (upward): expansion detected, amplification safe, magnification note, micro-actions
No advice, no strategy, no emotional comfort, no motivation.
	4.	No future references in Coherence Engine outputs
	•	The engine must not say or imply anything about “later”, “next”, “you will”, “this is your moment”, etc.
	5.	Amplification must not increase founder speed
	•	Amplification is allowed to clarify and stabilise momentum, not to accelerate or compress time.
	•	Pace lock: do not implement anything that implies “go faster” or “move now”.
	6.	Self-correction on drift
	•	If an output being generated violates drift rules (future reference, advice, emotional tone, motivation, cross-domain content), it must be rejected and regenerated using the self-correction sequence described in the spec:
	•	reject output
	•	reset temporary state
	•	re-enforce role contract
	•	re-classify present state
	•	We’ll encode drift checks in tests.

These constraints are not suggestions. They are design gates.

⸻

2. Repository & File Structure

Create a clean, minimal repo structure to hold the Coherence Engine service and its tests.

You decide language and framework (choose something modern and mainstream, suitable for building a small HTTP/JSON service with good test tooling).

Proposed layout (adapt as needed):
	•	/src/
	•	coherence_engine/
	•	models/ (data types: FounderStateInput, DiagnosticContext, MemorySnapshot, CoherencePacket, etc.)
	•	classification/ (integrity classifier, drift detection)
	•	amplification/ (upward detection, false-high detection, amplification planner)
	•	outputs/ (output builder + drift checker + self-correction)
	•	api/ (HTTP handlers for /coherence/evaluate, /coherence/stabilise-only, /coherence/amplify-only, /coherence/debug/drift-check)
	•	orchestration/ (if needed internally)
	•	/tests/
	•	test_classification_*.ext
	•	test_amplification_*.ext
	•	test_drift_guardrails.ext
	•	test_api_examples.ext
	•	SPEC.md (already exists – treat as reference)
	•	API_EXAMPLES.json (use for test fixtures)
	•	TESTS.md (turn into real automated tests)
	•	MVP_SLICE.md (guide the first implementation phase)
	•	README.md (for devs)

Do not remove or edit the spec files – only read them.

⸻

3. Implementation Phases

Follow these phases in order. Don’t jump ahead.

Phase 1 — MVP Slice (Stabilisation Only)

Use MVP_SLICE.md as the guiding document.
	1.	Implement the core data models as per the spec (no over-complication).
	2.	Implement /coherence/stabilise-only:
	•	Accepts founder_state, diagnostic_context, memory_snapshot.
	•	Classifies integrity state (Stable / Drift / Distortion / Pre-Collapse) using only present signals.
	•	Routes to a protocol where required (use a simple mapping table as described in the routing section of the spec).
	•	Emits a one-line stabilisation cue.
	•	Returns a complete coherence_packet without upward.
	3.	Add tests to validate:
	•	Correct classification for simple cases (urgency spike, numbness, shame, etc.).
	•	Correct routing (urgency → Holding My Rhythm; avoidance → What Am I Avoiding; etc.).
	•	No future language in any output.
	•	No advice, motivation, or emotional tone.

Do not implement amplification in Phase 1.

Phase 2 — Add Amplification (Upward Coherence)

Once stabilisation is robust, add:
	1.	Expansion signal detection (clean upward coherence).
	2.	False-high detection (unsafe “positive urgency”).
	3.	The upward block in coherence_packet for /coherence/evaluate.
	4.	Pace lock, embodiment gate, urgency kill-switch, micro-consent semantics (as mechanical rules – mostly encoded in classification and checks around upward output).

Add tests for:
	•	Clean expansion with safe amplification.
	•	False-high being treated as drift (routes back to stabilisation logic).
	•	Amplification never emitting future-facing or motivational content.

Phase 3 — Drift Guardrails & Self-Correction

Implement:
	1.	Drift output checker (string / token rules) that flags:
	•	future references
	•	advisory verbs
	•	motivational language
	•	emotional tone phrases
	•	cross-domain output
	2.	Self-correction loop: reject → reset → re-enforce contract → re-classify.

Extend tests accordingly (see below).

⸻

4. API-Level Examples

Use API_EXAMPLES.json as the starting point and then:
	•	Implement tests that send those example requests through the HTTP layer and assert:
	•	Response structure matches the spec.
	•	integrity_state is correct.
	•	protocol_route matches the routing table.
	•	upward is either null or correctly populated.
	•	No drift violations in the outputs.

Also create additional internal examples for at least:
	1.	Urgency spike
	•	Expect: DRIFT + route to Holding My Rhythm.
	2.	Numb, shut down founder
	•	Expect: PRE_COLLAPSE + exit precursor flag.
	3.	Calm, open, high capacity
	•	Expect: STABLE + upward.expansion_detected = true and safe amplification.
	4.	Hyped, fast-talking, oscillating
	•	Expect: drift or false-high → no amplification, route to stabilisation protocols.

⸻

5. Test Case Catalogue (Automated)

Use TESTS.md as the seed. Turn it into actual test code.

Categories of tests you must implement:
	1.	Classification correctness
	•	Map combinations of input signals to the correct integrity state.
	2.	Routing correctness
	•	Given an input “shape”, ensure the right protocol slug is selected.
	3.	Output schema integrity
	•	Coherence Engine outputs are always well-formed coherence_packets.
	•	No extra, undocumented fields.
	4.	Language drift guardrails
	•	Assert that outputs do not contain:
	•	“should”, “need to”, “you must”, “you can do it”, “this will”, “next you”, etc.
	•	Common future-tense markers.
	•	Motivational and therapeutic phrases.
	5.	Amplification safety
	•	Amplification never activates without:
	•	integrity_state == STABLE
	•	protocol cycle complete (stub this as a flag for now)
	•	founder readiness signal == true
	•	Amplification stops when urgency or contraction is introduced.
	6.	Memory non-interference
	•	When founder_state is identical and only memory_snapshot changes:
	•	integrity classification must remain unchanged.
	7.	Self-correction
	•	Inject a deliberately drift-violating candidate output (in a test-only hook).
	•	Assert that the engine:
	•	rejects it,
	•	resets,
	•	re-runs classification from present-state only,
	•	emits a clean output.

⸻

6. How to Use SPEC.md While Coding
	1.	Open SPEC.md and treat it as the single source of truth.
	•	If any detail in this prompt seems to conflict with SPEC.md, follow the spec and interpret this prompt as commentary.
	2.	Keep implementation close to the concepts:
	•	Each section in the spec (Inputs, Outputs, States, Drift, Memory, Amplification, etc.) should map to explicit modules, functions, or classes.
	3.	When in doubt about behavior:
	•	Prefer non-action over extra behavior.
	•	If something might look like advice, motivation, or future-reference, do not emit it.

⸻

7. Collaboration Protocol With Me (The Human)
	•	Do not ask me to write code.
	•	Do propose file names, structures, and function signatures.
	•	If you need information that can only come from me (e.g., URL paths, deployment environment, language choice), ask concise questions with clear options.
	•	Default to sensible, widely used tools and frameworks.

⸻

8. Final Outcome

When you’re done, I should have:
	1.	A runnable service that exposes the Coherence Engine HTTP API.
	2.	A full suite of tests that encode the drift rules and classification logic.
	3.	Clear instructions in README.md for:
	•	install
	•	run dev server
	•	run tests
	4.	A codebase that exactly implements the architecture in SPEC.md with zero drift and zero motivational/therapeutic contamination.

Start now by:
	1.	Reading SPEC.md, 
	2.	Proposing (and then creating) the concrete repo/file structure.
	3.	Implementing Phase 1 (stabilisation-only) end-to-end with tests.