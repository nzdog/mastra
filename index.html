<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lichen Field</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: #FAFAF9;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        html {
            overflow-y: scroll;
        }

        *:focus-visible {
            outline: 2px solid #57534E;
            outline-offset: 2px;
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Fade in animation */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .fade-in-section {
            opacity: 0;
            animation: fadeInUp 0.8s ease-out forwards;
        }

        .fade-in-only {
            opacity: 0;
            animation: fadeIn 0.8s ease-out forwards;
        }

        /* Fade out animation */
        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        .fade-out {
            animation: fadeOut 1.2s ease-out forwards;
        }

        /* Spin animation for logo */
        @keyframes spin {
            from {
                transform: translate(-50%, -50%) rotate(0deg);
            }
            to {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        @keyframes spinSlow {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        .logo-spin {
            animation: spin 20s linear infinite;
        }

        @media (prefers-reduced-motion: reduce) {
            .logo-spin-intro {
                animation: spinSlow 40s linear infinite !important;
            }
        }


        /* Section reveal button */
        .section-reveal-btn {
            font-size: 0.8125rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #78716C;
            background: transparent;
            border: none;
            box-shadow: inset 0 0 0 1px #D6D3D1;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: box-shadow 0.5s ease-out, background-color 0.5s ease-out;
            font-family: inherit;
            margin-top: 2rem;
            margin-bottom: 0.75rem;
            width: 100%;
            text-align: left;
        }

        .section-reveal-btn:hover:not(.revealed) {
            box-shadow: inset 0 0 0 1px #78716C;
            background: #FAFAF9;
        }

        .section-reveal-btn.revealed {
            box-shadow: inset 0 0 0 1px transparent;
            background: transparent;
            cursor: default;
            pointer-events: none;
        }

        .section-reveal-btn.fade-in-section,
        .walk-button.fade-in-section {
            animation: none;
            opacity: 1;
            transform: none;
        }

        /* Header */
        .page-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            border-bottom: 1px solid #E7E5E4;
            padding: 1.25rem 2rem;
            background: #FCFCFB;
            display: flex; /* Visible during intro flow */
            gap: 2rem;
            align-items: baseline;
            transition: opacity 0.8s ease-out;
        }
        
        .page-header.intro-mode .header-state,
        .page-header.intro-mode .theme-position,
        .page-header.intro-mode .cost-display,
        .page-header.intro-mode .header-center-logo {
            display: none;
        }

        /* Show header logo when protocol list is active */
        .page-header.intro-mode.protocol-list-active .header-center-logo {
            display: block !important;
            opacity: 0.85;
        }

        /* Spinning animation for header logo */
        .header-center-logo.spinning {
            animation: spinSlow 20s linear infinite;
        }

        .header-center-logo {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            height: 48px;
            width: auto;
            opacity: 0;
            will-change: transform;
            backface-visibility: hidden;
            -webkit-font-smoothing: antialiased;
            animation: spin 20s linear infinite;
            animation-play-state: paused;
            transition: opacity 1.2s ease-out;
        }

        .header-center-logo.visible {
            opacity: 0.85;
        }

        .header-center-logo.spinning {
            animation-play-state: running;
        }
        
        .cost-display {
            display: none; /* Hidden as requested */
            margin-left: auto;
            font-size: 0.75rem;
            color: #A8A29E;
            font-variant-numeric: tabular-nums;
        }

        .header-title {
            font-size: 0.875rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            color: #1C1917;
        }

        .header-state {
            font-size: 0.8125rem;
            font-weight: 500;
            color: #78716C;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .theme-position {
            font-size: 0.8125rem;
            color: #78716C;
            margin-left: auto;
        }

        /* State Header (legacy - keeping for walk mode) */
        .state-header {
            border-bottom: 1px solid #E7E5E4;
            padding: 1.25rem 2rem;
            background: #FCFCFB;
            display: none;
            gap: 2rem;
            align-items: baseline;
        }

        .state-header.active {
            display: flex;
        }

        .mode-indicator {
            font-size: 0.8125rem;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #57534E;
        }

        .protocol-name {
            font-size: 0.8125rem;
            color: #78716C;
            font-weight: 500;
        }

        /* Content Area */
        .content-area {
            flex: 1;
            overflow-y: auto;
            display: none; /* Hidden initially during intro flow */
            justify-content: center;
            margin-top: 70px; /* Account for fixed header height */
        }

        .content-area.visible {
            display: flex;
        }

        .field-container {
            max-width: 680px;
            width: 100%;
            padding: 2rem 2rem 4rem 2rem;
            display: flex;
            flex-direction: column;
            gap: 3rem;
        }

        /* Wider container for summary mode */
        .field-container.summary-container {
            max-width: 900px;
        }

        /* Protocol Selection */
        .protocol-selection-view {
            display: flex;
            flex-direction: column;
            padding-top: 4rem;
        }

        .protocol-selection-view.hidden {
            display: none;
        }

        .protocol-selection-header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .protocol-selection-title {
            font-size: 1.5rem;
            font-weight: 500;
            color: #1C1917;
            margin-bottom: 0.75rem;
        }

        .protocol-selection-subtitle {
            font-size: 1rem;
            color: #78716C;
            line-height: 1.6;
        }

        .protocol-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .protocol-card {
            border: 1px solid #E7E5E4;
            background: #FFFFFF;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .protocol-card:hover {
            border-color: #78716C;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        }

        .protocol-card-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            gap: 1rem;
        }

        .protocol-card-title {
            font-size: 1.125rem;
            font-weight: 500;
            color: #1C1917;
            line-height: 1.4;
            flex: 1;
        }

        .protocol-card-badge {
            font-size: 0.6875rem;
            color: #78716C;
            background: #F5F5F4;
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            white-space: nowrap;
            font-weight: 500;
        }

        .protocol-card-purpose {
            font-size: 0.9375rem;
            color: #57534E;
            line-height: 1.6;
        }

        .protocol-card-meta {
            font-size: 0.8125rem;
            color: #A8A29E;
            display: flex;
            gap: 1rem;
        }

        /* Entry State */
        .entry-view {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 60vh;
        }

        .entry-view.hidden {
            display: none;
        }

        .field-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: #78716C;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .entry-input {
            width: 100%;
            font-size: 1.5rem;
            line-height: 1.7;
            padding: 1.5rem 0;
            border: none;
            border-bottom: 1px solid #E7E5E4;
            background: transparent;
            color: #1C1917;
            transition: border-color 0.3s ease;
        }

        .entry-input:focus {
            outline: none;
            border-bottom-color: #78716C;
        }

        .entry-input::placeholder {
            color: #A8A29E;
        }

        .entry-hint {
            font-size: 0.9375rem;
            line-height: 1.6;
            color: #A8A29E;
        }

        /* Composer Output */
        .composer-output {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        /* Enhanced styling for completion summary */
        .composer-output.summary-mode {
            background: #FFFFFF;
            border: 1px solid #E7E5E4;
            border-radius: 8px;
            padding: 3rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            max-width: 800px;
            margin: 0 auto;
        }

        .composer-output.summary-mode .theme-title {
            font-size: 2.25rem;
            color: #1C1917;
            border-bottom: 3px solid #D6D3D1;
            padding-bottom: 1rem;
            margin-bottom: 2rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        /* Target h2 tags anywhere in summary mode */
        .composer-output.summary-mode h2,
        .composer-output.summary-mode .section-content h2 {
            display: block !important;
            font-size: 1.5rem;
            color: #1C1917;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            padding-top: 1rem;
            border-top: 2px solid #F5F5F4;
        }

        /* First h2 shouldn't have top margin or border */
        .composer-output.summary-mode h2:first-child,
        .composer-output.summary-mode .section-content h2:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        .composer-output.summary-mode h3,
        .composer-output.summary-mode .section-content h3 {
            font-size: 1.125rem;
            color: #57534E;
            margin-top: 2rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
            letter-spacing: -0.01em;
        }

        .composer-output.summary-mode p,
        .composer-output.summary-mode .section-content p {
            display: block !important;
            font-size: 1rem;
            line-height: 1.8;
            color: #292524;
            margin-bottom: 1.25rem;
            text-align: left;
        }

        .composer-output.summary-mode strong,
        .composer-output.summary-mode .section-content strong {
            color: #1C1917;
            font-weight: 600;
        }

        .composer-output.summary-mode ul,
        .composer-output.summary-mode ol,
        .composer-output.summary-mode .section-content ul,
        .composer-output.summary-mode .section-content ol {
            margin-left: 1.75rem;
            margin-bottom: 1.5rem;
            padding-left: 0;
        }

        .composer-output.summary-mode li,
        .composer-output.summary-mode .section-content li {
            font-size: 1rem;
            line-height: 1.8;
            color: #292524;
            margin-bottom: 0.75rem;
        }

        .theme-title {
            font-size: 1.75rem;
            font-weight: 500;
            color: #1C1917;
            margin-bottom: 1rem;
            line-height: 1.4;
        }

        .output-section {
            line-height: 1.7;
            color: #292524;
        }

        .section-label {
            font-size: 0.8125rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #78716C;
            margin-bottom: 0.75rem;
        }

        .section-content {
            font-size: 1.0625rem;
            line-height: 1.7;
        }

        /* Response Area */
        .response-area {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #E7E5E4;
        }

        .response-input {
            width: 100%;
            font-size: 1.125rem;
            line-height: 1.7;
            padding: 1.25rem 0;
            border: none;
            border-bottom: 1px solid #E7E5E4;
            background: transparent;
            color: #1C1917;
            transition: border-color 0.3s ease;
            font-family: inherit;
            resize: none;
            min-height: 80px;
        }

        .response-input:focus {
            outline: none;
            border-bottom-color: #78716C;
        }

        .response-input::placeholder {
            color: #A8A29E;
        }

        .response-hint {
            font-size: 0.8125rem;
            color: #A8A29E;
            margin-top: 0.5rem;
            text-align: left;
        }

        /* Walk Controls */
        .walk-control {
            margin-top: 1.5rem;
            display: flex;
            justify-content: flex-end;
        }

        .walk-button {
            background: transparent;
            border: 1px solid #D6D3D1;
            color: #57534E;
            padding: 0.75rem 1.5rem;
            font-size: 0.9375rem;
            font-weight: 400;
            cursor: pointer;
            transition: border-color 1.2s ease-out, background 1.2s ease-out;
            font-family: inherit;
            position: relative; /* Always relative to prevent layout shift */
            display: inline-block;
            white-space: nowrap;
        }

        .walk-button:hover:not(:disabled) {
            /* No hover effect - border stays visible until clicked */
        }

        .walk-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .walk-button.loading {
            opacity: 0.6;
        }

        .walk-button.clicked {
            border-color: transparent;
            background: transparent;
            color: #57534E; /* Keep text color unchanged */
        }
        
        .walk-button.clicked:disabled {
            border-color: transparent;
            background: transparent;
            color: #57534E; /* Keep text color unchanged */
        }


        /* Error Strip */
        .error-strip {
            background: #FAFAF9;
            border: 1px solid #E7E5E4;
            border-left: 2px solid #DC2626;
            padding: 0.875rem 1rem;
            margin-bottom: 1.5rem;
            display: none;
        }

        .error-strip.active {
            display: block;
        }

        .error-message {
            font-size: 0.875rem;
            line-height: 1.6;
            color: #78716C;
        }

        /* Completion Overlay */
        .completion-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(250, 249, 249, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .completion-overlay.active {
            display: flex;
        }

        .completion-message {
            text-align: center;
        }

        .completion-title {
            font-size: 1.25rem;
            font-weight: 500;
            color: #1C1917;
            margin-bottom: 0.75rem;
        }

        .completion-subtitle {
            font-size: 0.9375rem;
            color: #78716C;
            font-style: italic;
        }

        /* Supports Strip - DISABLED */
        .supports-strip {
            display: none !important; /* Commented out - not working */
        }

        /* .supports-strip.active {
            display: block;
        } */

        .supports-container {
            display: flex;
            gap: 0.75rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        .supports-label {
            font-size: 0.625rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #A8A29E;
            padding: 0.625rem 0;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }

        .support-card {
            border: 1px solid #F5F5F4;
            background: #FEFEFE;
            transition: all 0.2s ease;
            min-width: 200px;
            max-width: 280px;
            cursor: pointer;
        }

        .support-card:hover {
            border-color: #E7E5E4;
        }

        .support-header {
            padding: 0.625rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .support-source {
            font-size: 0.625rem;
            font-weight: 600;
            color: #78716C;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .support-theme {
            font-size: 0.6875rem;
            color: #A8A29E;
            line-height: 1.4;
        }

        .support-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .support-body.expanded {
            max-height: 400px;
            overflow-y: auto;
        }

        .support-content {
            padding: 0 0.625rem 0.625rem 0.625rem;
            font-size: 0.75rem;
            line-height: 1.5;
            color: #57534E;
            font-family: ui-monospace, monospace;
            white-space: pre-wrap;
            border-top: 1px solid #F5F5F4;
            padding-top: 0.625rem;
        }

        /* Intro Flow Styles */
        .intro-flow-view {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 2rem;
            max-width: 100%;
            margin: 0 auto;
        }

        .intro-flow-view.hidden {
            display: none;
        }

        .intro-logo-container {
            position: absolute;
            top: calc(33vh - 70px);
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .logo-spin-intro {
            width: 96px;
            height: 96px;
            opacity: 0.85;
            animation: spinSlow 20s linear infinite;
        }

        .intro-content {
            width: 100%;
            max-width: 900px;
            display: flex;
            flex-direction: column;
            gap: 4rem;
            position: relative;
        }

        #intro-embodiment-lines {
            position: relative;
            width: 100%;
        }

        .intro-text-line {
            position: absolute;
            top: calc(33% - 70px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.125rem;
            line-height: 1.7;
            color: #57534E;
            font-style: italic;
            text-align: center;
            opacity: 0;
            z-index: 200;
            white-space: nowrap;
            display: inline-block;
            width: auto;
        }

        .intro-quote {
            position: absolute;
            top: calc(33% - 70px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.125rem;
            line-height: 1.7;
            color: #57534E;
            font-style: italic;
            text-align: center;
            opacity: 0;
            z-index: 200;
            white-space: nowrap;
            display: inline-block;
            width: auto;
        }

        .intro-quote-attribution {
            position: absolute;
            top: calc(33% + 45px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.9375rem;
            color: #78716C;
            text-align: center;
            opacity: 0;
            z-index: 200;
            display: inline-block;
        }

        /* Desktop/Mobile visibility classes */
        .desktop-only {
            display: block;
        }

        .mobile-only {
            display: none;
        }

        .intro-orientation {
            position: absolute;
            top: calc(33% - 70px);
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.125rem;
            line-height: 1.7;
            color: #57534E;
            font-style: italic;
            text-align: center;
            opacity: 0;
            z-index: 200;
            white-space: nowrap;
            display: inline-block;
            width: auto;
        }

        .intro-sequence-container {
            opacity: 0;
            width: 100%;
            display: none; /* Hide sequence list */
        }

        .intro-sequence-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .intro-sequence-item {
            font-size: 1rem;
            line-height: 1.6;
            color: #57534E;
            padding-left: 2rem;
            position: relative;
        }

        .intro-sequence-item::before {
            content: attr(data-number);
            position: absolute;
            left: 0;
            color: #A8A29E;
            font-size: 0.875rem;
        }

        .intro-sequence-item.prelude {
            font-style: italic;
            color: #78716C;
        }

        .intro-sequence-item.prelude::before {
            content: '◆';
            font-style: normal;
        }

        .intro-sequence-subtext {
            font-size: 0.875rem;
            color: #A8A29E;
            text-align: center;
            margin-top: 1.5rem;
            font-style: italic;
        }

        .intro-protocol-deck {
            opacity: 0;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            margin-top: 3rem;
            width: 100%;
        }

        .intro-protocol-card {
            border: 1px solid #E7E5E4;
            background: #FFFFFF;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 600px;
            width: 100%;
        }

        .intro-protocol-title {
            font-size: 1.125rem;
            font-weight: 500;
            color: #1C1917;
            line-height: 1.4;
        }

        .intro-disclosure-section {
            max-height: 0;
            margin-top: 0.5rem;
            opacity: 0;
            overflow: hidden;
            transition: max-height 3s ease, opacity 3s ease;
        }

        .intro-disclosure-section.visible {
            max-height: 1000px;
            opacity: 1;
        }

        .intro-disclosure-label {
            font-size: 0.8125rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #78716C;
            margin-bottom: 0.5rem;
        }

        .intro-disclosure-content {
            font-size: 0.9375rem;
            line-height: 1.7;
            color: #57534E;
        }

        .intro-disclosure-content ul {
            list-style: none;
            padding-left: 1rem;
            margin: 0.5rem 0;
        }

        .intro-disclosure-content li {
            position: relative;
            padding-left: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .intro-disclosure-content li::before {
            content: '−';
            position: absolute;
            left: -0.75rem;
            color: #A8A29E;
        }

        .intro-disclosure-btn {
            font-size: 0.8125rem;
            font-weight: 500;
            letter-spacing: 0.03em;
            color: #78716C;
            background: transparent;
            border: 1px solid #E7E5E4;
            padding: 0.625rem 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            margin-top: 0.75rem;
            text-align: left;
            width: 100%;
        }

        .intro-disclosure-btn:hover {
            border-color: #78716C;
            background: #FAFAF9;
        }

        .intro-disclosure-btn:focus-visible {
            outline: 2px solid #57534E;
            outline-offset: 2px;
        }

        .intro-walk-btn {
            font-size: 0.8125rem;
            font-weight: 500;
            letter-spacing: 0.03em;
            color: #78716C;
            background: transparent;
            border: 1px solid #E7E5E4;
            padding: 0.625rem 1rem;
            cursor: pointer;
            transition: border-color 1.5s ease, color 0.3s ease, background 0.3s ease;
            font-family: inherit;
            text-align: center;
            display: none;
            margin-top: 0.5rem;
        }

        .intro-walk-btn:hover {
            border-color: #78716C;
            background: #FAFAF9;
        }

        .intro-walk-btn:focus-visible {
            outline: 2px solid #57534E;
            outline-offset: 2px;
        }

        .intro-walk-btn.dissolving {
            border-color: transparent;
        }

        .intro-continue-container {
            position: absolute;
            top: calc(33% + 198px);
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            text-align: center;
            z-index: 200;
        }

        .intro-continue-btn {
            background: transparent;
            border: 1px solid #D6D3D1;
            color: #57534E;
            padding: 0.875rem 2rem;
            font-size: 1rem;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .intro-continue-btn:hover {
            border-color: #78716C;
            background: #FAFAF9;
        }

        .intro-continue-btn:focus-visible {
            outline: 2px solid #57534E;
            outline-offset: 2px;
        }

        .intro-continue-hint {
            font-size: 0.8125rem;
            color: #A8A29E;
            margin-top: 0.5rem;
        }

        .intro-begin-container {
            opacity: 0;
            margin-top: 3rem;
            text-align: center;
        }

        .intro-begin-btn {
            background: transparent;
            border: 1px solid #D6D3D1;
            color: #57534E;
            padding: 0.875rem 2rem;
            font-size: 1rem;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .intro-begin-btn:hover {
            border-color: #78716C;
            background: #FAFAF9;
        }

        .intro-begin-btn:focus-visible {
            outline: 2px solid #57534E;
            outline-offset: 2px;
        }

        .intro-protocol-list-page {
            display: none;
            flex-direction: column;
            align-items: center;
            padding-top: calc(33% - 70px + 60px);
            max-width: 900px;
            margin: 0 auto;
        }

        .intro-protocol-list-page.visible {
            display: flex;
        }

        /* Live region for screen readers */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* ========================================
           MOBILE RESPONSIVE STYLES
           ======================================== */

        /* Tablets and small screens */
        @media (max-width: 768px) {
            /* Show mobile version, hide desktop version */
            .desktop-only {
                display: none !important;
            }

            .mobile-only {
                display: block !important;
            }

            /* Logo adjustments */
            .logo-spin-intro {
                width: 80px;
                height: 80px;
            }

            .intro-logo-container {
                top: calc(40vh - 40px);
            }

            /* Typography scaling - mobile version only */
            .intro-quote.mobile-only {
                position: relative !important;
                font-size: 1.0625rem;
                white-space: normal !important;
                left: auto !important;
                right: auto !important;
                margin-left: 7.5% !important;
                margin-right: 7.5% !important;
                transform: none !important;
                display: block !important;
                width: auto !important;
                line-height: 1.5 !important;
                top: auto !important;
            }

            .intro-text-line {
                font-size: 1.0625rem;
                white-space: normal !important;
                left: 7.5% !important;
                right: 7.5% !important;
                transform: translateX(0) !important;
                display: block !important;
                width: auto !important;
                line-height: 1.5 !important;
            }

            .intro-orientation {
                font-size: 1.0625rem;
                white-space: normal !important;
                left: 7.5% !important;
                right: 7.5% !important;
                transform: none !important;
                display: block !important;
                width: auto !important;
                line-height: 1.5 !important;
            }

            /* Adjust spacing for smaller screens */
            .intro-flow-view {
                padding: 1.5rem;
            }

            /* Safari fix: Force explicit width calculation for absolutely positioned children */
            .intro-content {
                width: 100vw !important;
                max-width: 100vw !important;
                left: 0 !important;
                right: 0 !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
            }

            .intro-protocol-list-page {
                padding-top: 0px;
            }

            /* Protocol cards */
            .intro-protocol-card {
                max-width: 100%;
                padding: 1.25rem;
            }

            .intro-protocol-deck {
                gap: 1.5rem;
                margin-top: 2rem;
            }

            /* Buttons - ensure touch targets */
            .intro-disclosure-btn,
            .intro-walk-btn {
                padding: 0.75rem 1rem;
                min-height: 44px;
            }

            .intro-continue-btn,
            .intro-begin-btn {
                padding: 1rem 2rem;
                min-height: 44px;
            }

            /* Adjust vertical spacing */
            .intro-continue-container {
                top: calc(28vh + 160px);
            }

            /* === PROTOCOL WALK INTERFACE === */

            /* Header adjustments for walk mode */
            .header-center-logo {
                height: 36px;
            }

            .page-header {
                gap: 1rem;
            }

            .theme-position {
                font-size: 0.75rem;
            }

            /* Truncate header title to prevent overlap with center logo */
            .header-title {
                max-width: 40%;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            /* Content area */
            .content-area {
                margin-top: 60px;
            }

            .field-container {
                padding: 1.5rem 1.5rem 3rem 1.5rem;
                gap: 2.5rem;
            }

            /* Protocol selection page */
            .protocol-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 1.25rem;
            }

            .protocol-card {
                padding: 1.25rem;
            }

            .protocol-selection-title {
                font-size: 1.375rem;
            }

            /* Entry view */
            .entry-input {
                font-size: 1.25rem;
                padding: 1.25rem 0;
            }

            /* Walk interface */
            .response-input {
                font-size: 1rem;
                padding: 1rem 0;
                min-height: 70px;
            }

            .theme-title {
                font-size: 1.5rem;
            }

            .section-content {
                font-size: 1rem;
            }

            /* Buttons */
            .walk-button {
                padding: 0.875rem 1.5rem;
                min-height: 44px;
                font-size: 0.875rem;
            }

            /* Summary mode */
            .composer-output.summary-mode {
                padding: 2rem;
            }

            .composer-output.summary-mode .theme-title {
                font-size: 2rem;
            }

            .composer-output.summary-mode h2,
            .composer-output.summary-mode .section-content h2 {
                font-size: 1.25rem;
            }

            .composer-output.summary-mode h3,
            .composer-output.summary-mode .section-content h3 {
                font-size: 1rem;
            }

            .composer-output.summary-mode p,
            .composer-output.summary-mode .section-content p {
                font-size: 0.9375rem;
            }
        }

        /* Mobile phones */
        @media (max-width: 480px) {
            /* Show mobile version, hide desktop version */
            .desktop-only {
                display: none !important;
            }

            .mobile-only {
                display: block !important;
            }

            /* Further logo reduction */
            .logo-spin-intro {
                width: 64px;
                height: 64px;
            }

            .intro-logo-container {
                top: calc(40vh - 32px);
            }

            /* Typography - even smaller - mobile version only */
            .intro-quote.mobile-only {
                position: relative !important;
                font-size: 1rem;
                line-height: 1.4 !important;
                left: auto !important;
                right: auto !important;
                margin-left: 5% !important;
                margin-right: 5% !important;
                transform: none !important;
                padding: 0 0.5rem;
                box-sizing: border-box;
                display: block !important;
                white-space: normal !important;
                width: auto !important;
                top: auto !important;
            }

            .intro-text-line {
                font-size: 1rem;
                line-height: 1.4 !important;
                left: 5% !important;
                right: 5% !important;
                transform: translateX(0) !important;
                padding: 0 0.5rem;
                box-sizing: border-box;
                display: block !important;
                white-space: normal !important;
                width: auto !important;
            }

            .intro-orientation {
                font-size: 1rem;
                line-height: 1.4 !important;
                left: 5% !important;
                right: 5% !important;
                transform: none !important;
                padding: 0 0.5rem;
                box-sizing: border-box;
                display: block !important;
                white-space: normal !important;
                width: auto !important;
            }

            /* Tighter spacing */
            .intro-flow-view {
                padding: 1rem;
            }

            /* Safari fix: Force explicit width calculation for absolutely positioned children */
            .intro-content {
                width: 100vw !important;
                max-width: 100vw !important;
                left: 0 !important;
                right: 0 !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
            }

            .intro-protocol-list-page {
                padding-top: 0px;
            }

            /* Cards - full width with minimal padding */
            .intro-protocol-card {
                padding: 1rem;
                font-size: 0.9375rem;
            }

            .intro-protocol-title {
                font-size: 1rem;
            }

            .intro-protocol-deck {
                gap: 1.25rem;
                margin-top: 1.5rem;
            }

            .intro-disclosure-content {
                font-size: 0.875rem;
            }

            /* Adjust button text size */
            .intro-disclosure-btn,
            .intro-walk-btn {
                font-size: 0.75rem;
                padding: 0.875rem 1rem;
            }

            .intro-continue-btn,
            .intro-begin-btn {
                font-size: 0.9375rem;
                padding: 0.875rem 1.5rem;
            }

            /* Continue button position */
            .intro-continue-container {
                top: calc(25vh + 140px);
            }

            .intro-continue-hint {
                font-size: 0.75rem;
            }

            /* Header adjustments */
            .page-header {
                padding: 1rem 1.25rem;
            }

            /* Reduce line spacing on mobile */
            .intro-content {
                gap: 3rem;
            }

            /* === PROTOCOL WALK INTERFACE - SMALL MOBILE === */

            /* Header - tighter for small screens */
            .header-center-logo {
                height: 28px;
            }

            .page-header {
                padding: 0.75rem 1rem;
                gap: 0.75rem;
            }

            .header-title {
                font-size: 0.8125rem;
                max-width: 35%;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .header-state {
                font-size: 0.75rem;
            }

            /* Hide theme position on very small screens */
            .theme-position {
                display: none;
            }

            /* Content area */
            .content-area {
                margin-top: 55px;
            }

            .field-container {
                padding: 1rem 1rem 2.5rem 1rem;
                gap: 2rem;
            }

            .field-container.summary-container {
                max-width: 100%;
            }

            /* Protocol selection */
            .protocol-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .protocol-card {
                padding: 1rem;
            }

            .protocol-card-title {
                font-size: 1rem;
            }

            .protocol-card-purpose {
                font-size: 0.875rem;
            }

            .protocol-selection-title {
                font-size: 1.25rem;
            }

            .protocol-selection-subtitle {
                font-size: 0.9375rem;
            }

            /* Entry view */
            .entry-view {
                min-height: 50vh;
            }

            .entry-input {
                font-size: 1.125rem;
                padding: 1rem 0;
            }

            #protocol-title {
                font-size: 1.25rem !important;
            }

            /* Walk interface */
            .response-input {
                font-size: 0.9375rem;
                padding: 0.875rem 0;
                min-height: 60px;
            }

            .response-hint {
                font-size: 0.75rem;
            }

            .theme-title {
                font-size: 1.25rem;
                margin-bottom: 0.875rem;
            }

            .section-label {
                font-size: 0.75rem;
            }

            .section-content {
                font-size: 0.9375rem;
            }

            .output-section {
                gap: 1rem;
            }

            /* Buttons */
            .walk-button {
                padding: 1rem 1.25rem;
                font-size: 0.8125rem;
                width: 100%;
            }

            .walk-control {
                flex-direction: column;
                gap: 0.75rem;
            }

            /* Summary mode - compact for mobile */
            .composer-output.summary-mode {
                padding: 1.25rem;
                border-radius: 0;
            }

            .composer-output.summary-mode .theme-title {
                font-size: 1.5rem;
                margin-bottom: 1.5rem;
                padding-bottom: 0.75rem;
            }

            .composer-output.summary-mode h2,
            .composer-output.summary-mode .section-content h2 {
                font-size: 1.125rem;
                margin-top: 2rem;
                margin-bottom: 0.75rem;
            }

            .composer-output.summary-mode h3,
            .composer-output.summary-mode .section-content h3 {
                font-size: 0.9375rem;
                margin-top: 1.5rem;
            }

            .composer-output.summary-mode p,
            .composer-output.summary-mode .section-content p {
                font-size: 0.875rem;
                line-height: 1.7;
                margin-bottom: 1rem;
            }

            .composer-output.summary-mode li,
            .composer-output.summary-mode .section-content li {
                font-size: 0.875rem;
            }

            /* Completion buttons - stack on mobile */
            #walk-control .walk-button,
            .completion-container .walk-button {
                width: 100%;
            }

            /* Entry logo size */
            #lichen-logo {
                height: 60px !important;
            }

            /* Section reveal buttons */
            .section-reveal-btn {
                font-size: 0.75rem;
                padding: 0.75rem 0.875rem;
            }

            /* Response area */
            .response-area {
                margin-top: 1.5rem;
                padding-top: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Page Header -->
    <div class="page-header intro-mode" id="page-header">
        <div class="header-title">
            Lichen
        </div>
        <img src="/lichen-logo.png" alt="" class="header-center-logo" id="header-center-logo">
        <div class="header-state" id="header-state">Entry</div>
        <div class="theme-position" id="theme-position"></div>
        <div class="cost-display" id="cost-display">$0.00</div>
    </div>

    <!-- State Header (legacy - for walk mode) -->
    <div class="state-header" id="state-header" style="display: none;">
        <div class="mode-indicator" id="mode-indicator">Entry</div>
        <div class="protocol-name" id="protocol-name"></div>
    </div>

    <!-- Screen reader announcements -->
    <div class="sr-only" role="status" aria-live="polite" aria-atomic="true" id="sr-announcer"></div>

    <!-- Intro Flow View -->
    <div class="intro-flow-view" id="intro-flow-view">
        <!-- Spinning Logo -->
        <div class="intro-logo-container">
            <img src="/lichen-logo.png" alt="Lichen" class="logo-spin-intro">
        </div>

        <div class="intro-content" id="intro-content">
            <!-- Quote - Desktop Version -->
            <div class="intro-quote desktop-only" id="intro-quote-desktop">
                "The field is the sole governing agency of the particle."
            </div>

            <!-- Quote - Mobile Version (Inline Attribution) -->
            <div class="intro-quote mobile-only" id="intro-quote-mobile">
                "The field is the sole governing agency of the particle." — Albert Einstein
            </div>

            <!-- Embodiment Lines -->
            <div id="intro-embodiment-lines"></div>

            <!-- Orientation (hidden) -->
            <div class="intro-orientation" id="intro-orientation" style="display: none;">
                Orientation with the system is six protocols long
            </div>

            <!-- Continue Button (shown after orientation) -->
            <div class="intro-continue-container" id="intro-continue-container">
                <button class="intro-continue-btn" id="intro-continue-btn">Continue</button>
                <div class="intro-continue-hint">Press Shift + Enter</div>
            </div>
        </div>

        <!-- Protocol List Page (shown after Continue) -->
        <div class="intro-protocol-list-page" id="intro-protocol-list-page">
            <!-- Sequence List -->
            <div class="intro-sequence-container" id="intro-sequence-container">
                <ul class="intro-sequence-list">
                    <li class="intro-sequence-item prelude">Field Diagnostic (prelude)</li>
                    <li class="intro-sequence-item" data-number="1.">Knowing When a Field Must End</li>
                    <li class="intro-sequence-item" data-number="2.">Composting the Old Signal</li>
                    <li class="intro-sequence-item" data-number="3.">Extracting the Gifts Without Carrying the Pattern</li>
                    <li class="intro-sequence-item" data-number="4.">Designing a Clean Exit</li>
                    <li class="intro-sequence-item" data-number="5.">Walking Forward Without Residue</li>
                </ul>
                <div class="intro-sequence-subtext">Each stage opens the next. You will be guided, one step at a time.</div>
            </div>

            <!-- Protocol Deck -->
            <div class="intro-protocol-deck" id="intro-protocol-deck">
                <!-- Protocol cards will be populated by JavaScript -->
            </div>

            <!-- Begin Button -->
            <div class="intro-begin-container" id="intro-begin-container">
                <button class="intro-begin-btn" id="intro-begin-btn">Begin</button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="content-area">
        <div class="field-container" id="main-content">
            <!-- Protocol Selection View -->
            <div class="protocol-selection-view hidden" id="protocol-selection-view">
                <div class="protocol-selection-header">
                    <img src="/lichen-logo.png" alt="Lichen" style="height: 80px; width: auto; margin-bottom: 2rem;">
                    <div class="protocol-selection-title">Choose Your Protocol</div>
                    <div class="protocol-selection-subtitle">Select a protocol to begin your walk</div>
                </div>
                <div class="protocol-grid" id="protocol-grid">
                    <!-- Protocol cards will be populated by JavaScript -->
                </div>
            </div>

            <!-- Entry View -->
            <div class="entry-view hidden" id="entry-view">
                <img src="/lichen-logo.png" alt="Lichen" id="lichen-logo" style="height: 80px; width: auto; margin-bottom: 2rem;">
                <div id="protocol-title" style="font-size: 1.5rem; font-weight: 500; color: #78716C; margin-bottom: 3rem; text-align: center; line-height: 1.4;">Field Diagnostic Protocol</div>
                <button class="walk-button" id="begin-button">Begin walk</button>
            </div>

            <!-- Walk View (hidden initially) -->
            <div id="walk-view" style="display: none; transition: opacity 0.8s ease-out;">
                <!-- Error Strip -->
                <div class="error-strip" id="error-strip">
                    <div class="error-message" id="error-message"></div>
                </div>

                <!-- Composer Output -->
                <div class="composer-output" id="composer-output"></div>

                <!-- Response Area -->
                <div class="response-area">
                    <textarea
                        class="response-input"
                        id="response-input"
                        placeholder="Your response..."
                        rows="3"
                    ></textarea>
                    <div class="response-hint" id="response-hint"></div>

                    <div class="walk-control" id="walk-control">
                        <button class="walk-button" id="continue-button" disabled aria-label="Continue (Ctrl or Cmd + Enter)">Continue</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Supports Strip - DISABLED -->
    <!-- <div class="supports-strip" id="supports-strip">
        <div class="supports-container" id="supports-container"></div>
    </div> -->

    <!-- Completion Overlay -->
    <div class="completion-overlay" id="completion-overlay">
        <div class="completion-message">
            <div class="completion-title" id="overlay-title">Protocol complete.</div>
            <div class="completion-subtitle" id="overlay-subtitle">The field rests.</div>
        </div>
    </div>

    <script type="module">
        // API Integration - automatically detects environment
        const API_BASE = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000'
            : 'https://web-production-b6320.up.railway.app'; // Railway backend URL
        
        let sessionId = null;
        let currentMode = 'ENTRY';
        let protocolData = null;
        let selectedProtocol = null; // Store selected protocol

        // DOM Elements - Intro Flow
        const introFlowView = document.getElementById('intro-flow-view');
        const introQuoteDesktop = document.getElementById('intro-quote-desktop');
        const introQuoteMobile = document.getElementById('intro-quote-mobile');
        const introEmbodimentLines = document.getElementById('intro-embodiment-lines');
        const introOrientation = document.getElementById('intro-orientation');
        const introContinueContainer = document.getElementById('intro-continue-container');
        const introContinueBtn = document.getElementById('intro-continue-btn');
        const introContent = document.getElementById('intro-content');
        const introProtocolListPage = document.getElementById('intro-protocol-list-page');
        const introSequenceContainer = document.getElementById('intro-sequence-container');
        const introProtocolDeck = document.getElementById('intro-protocol-deck');
        const introBeginContainer = document.getElementById('intro-begin-container');
        const introBeginBtn = document.getElementById('intro-begin-btn');
        const srAnnouncer = document.getElementById('sr-announcer');

        // DOM Elements - Main App
        const protocolSelectionView = document.getElementById('protocol-selection-view');
        const protocolGrid = document.getElementById('protocol-grid');
        const protocolTitle = document.getElementById('protocol-title');
        const entryView = document.getElementById('entry-view');
        const walkView = document.getElementById('walk-view');
        const entryInput = document.getElementById('entry-input');
        const beginButton = document.getElementById('begin-button');
        const responseInput = document.getElementById('response-input');
        const continueButton = document.getElementById('continue-button');
        const pageHeader = document.getElementById('page-header');
        const headerState = document.getElementById('header-state');
        const headerCenterLogo = document.getElementById('header-center-logo');
        const stateHeader = document.getElementById('state-header');
        const modeIndicator = document.getElementById('mode-indicator');
        const protocolName = document.getElementById('protocol-name');
        const themePosition = document.getElementById('theme-position');
        const composerOutput = document.getElementById('composer-output');
        // const supportsStrip = document.getElementById('supports-strip');
        // const supportsContainer = document.getElementById('supports-container');
        const errorStrip = document.getElementById('error-strip');
        const errorMessage = document.getElementById('error-message');
        const responseHint = document.getElementById('response-hint');
        const costDisplay = document.getElementById('cost-display');

        // ========================================
        // INTRO FLOW LOGIC
        // ========================================

        // Timing constants (tunable)
        const TIMING = {
            initialWait: 2000,       // 2s wait before first line
            jigsawDuration: 400,     // 0.4s jigsaw animation
            lineDuration: 3000,      // 3s line stays visible
            fadeOutDuration: 1000,   // 1s fade out
            beforeOrientation: 1200, // 1.2s pause before orientation
            beforeSequence: 1700,    // 1.7s pause before sequence
        };

        // Check for reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // Announce text for screen readers
        function announceForScreenReader(text) {
            if (srAnnouncer) {
                srAnnouncer.textContent = text;
                setTimeout(() => {
                    srAnnouncer.textContent = '';
                }, 1000);
            }
        }

        // Fade in an element (opacity only)
        function fadeIn(element, duration = 1000) {
            return new Promise(resolve => {
                if (!element) {
                    resolve();
                    return;
                }
                element.style.transition = `opacity ${duration}ms ease`;
                element.style.opacity = '1';
                setTimeout(resolve, duration);
            });
        }

        // Fade in with forced text reset (for intro flow only)
        function fadeInClean(element, duration = 1000) {
            return new Promise(resolve => {
                if (!element) {
                    resolve();
                    return;
                }
                // Force clean text content (strips any spans)
                const text = element.textContent;
                element.textContent = text;
                
                element.style.transition = `opacity ${duration}ms ease`;
                element.style.opacity = '1';
                setTimeout(resolve, duration);
            });
        }

        // Fade out an element
        function fadeOut(element, duration = TIMING.fadeOutDuration) {
            return new Promise(resolve => {
                if (!element) {
                    resolve();
                    return;
                }
                element.style.transition = `opacity ${duration}ms ease`;
                element.style.opacity = '0';
                setTimeout(resolve, duration);
            });
        }

        // Run the intro flow sequence
        async function runIntroFlow() {
            console.log('Starting intro flow...');
            console.log('introQuoteDesktop element:', introQuoteDesktop);
            console.log('introQuoteMobile element:', introQuoteMobile);
            console.log('introEmbodimentLines element:', introEmbodimentLines);
            
            // Reset all text to plain text for both desktop and mobile versions
            if (introQuoteDesktop) {
                introQuoteDesktop.textContent = '"The field is the sole governing agency of the particle." — Albert Einstein';
            }
            if (introQuoteMobile) {
                introQuoteMobile.textContent = '"The field is the sole governing agency of the particle." — Albert Einstein';
            }

            // 1. Wait 2 seconds with logo visible and spinning
            await new Promise(resolve => setTimeout(resolve, TIMING.initialWait));
            console.log('Initial wait complete, showing quote...');

            // 2. Show quote with simple fade (0.86s) - both desktop and mobile versions
            // The CSS will handle showing only the appropriate version
            if (introQuoteDesktop && introQuoteMobile) {
                // Fade in both versions (CSS controls which one is visible)
                await Promise.all([
                    fadeInClean(introQuoteDesktop, 860),
                    fadeInClean(introQuoteMobile, 860)
                ]);

                // Announce for screen readers (use desktop version text)
                announceForScreenReader('"The field is the sole governing agency of the particle." — Albert Einstein');

                // Wait 3 seconds total before greying out
                await new Promise(resolve => setTimeout(resolve, 3000));

                // Grey out both versions
                introQuoteDesktop.style.transition = 'opacity 500ms ease, color 500ms ease';
                introQuoteDesktop.style.opacity = '0.6';
                introQuoteDesktop.style.color = '#78716C';

                introQuoteMobile.style.transition = 'opacity 500ms ease, color 500ms ease';
                introQuoteMobile.style.opacity = '0.6';
                introQuoteMobile.style.color = '#78716C';

                await new Promise(resolve => setTimeout(resolve, 500)); // Wait for grey transition

                console.log('Quote complete');
            } else {
                console.error('Quote elements not found!');
            }

            // 3. Show each embodiment line with jigsaw fade, one at a time
            const embodimentLines = [
                "You are the particle.",
                "Every decision, every signal, every relationship is shaped by the field you're in.",
                "The Lichen System listens to that field.",
                "It helps you see where you are.",
                "It helps you transform the field when the time is right."
            ];

            let previousLine = null;
            for (let i = 0; i < embodimentLines.length; i++) {
                const lineText = embodimentLines[i];
                const line = document.createElement('div');
                line.className = 'intro-text-line';
                line.textContent = lineText;
                // Move first two lines: up 3px on desktop, up 20px on mobile
                const isMobile = window.innerWidth <= 768;
                const offset = (i < 2) ? (isMobile ? -20 : -3) : 0;
                line.style.top = `calc(33% - 70px + ${60 + (i * 40) + offset}px)`; // Start 60px below Einstein quote, moved up 70px for header
                introEmbodimentLines.appendChild(line);
                
                // Grey out the previous line BEFORE showing the next one
                if (previousLine) {
                    previousLine.style.transition = 'opacity 500ms ease, color 500ms ease';
                    previousLine.style.opacity = '0.6';
                    previousLine.style.color = '#78716C';
                    await new Promise(resolve => setTimeout(resolve, 500)); // Wait for grey transition
                }
                
                await fadeInClean(line, 860);
                announceForScreenReader(lineText);
                await new Promise(resolve => setTimeout(resolve, TIMING.lineDuration));
                
                previousLine = line;
            }

            // 4. Grey out the last embodiment line
            if (previousLine) {
                previousLine.style.transition = 'opacity 500ms ease, color 500ms ease';
                previousLine.style.opacity = '0.6';
                previousLine.style.color = '#78716C';
                await new Promise(resolve => setTimeout(resolve, 500)); // Wait for grey transition
            }
            await new Promise(resolve => setTimeout(resolve, TIMING.beforeOrientation));

            // 5. Show continue button
            await fadeIn(introContinueContainer, 800);
            console.log('Continue button visible, waiting for user action...');

            // Wait for user to click continue
            // The rest will be handled by the continue button click handler
        }

        // Handle Continue button click - show protocol list page
        async function showProtocolListPage() {
            console.log('Showing protocol list page...');

            // Scroll to top
            window.scrollTo(0, 0);

            // Fade out the intro content (quote, embodiment lines, orientation, continue button)
            await fadeOut(introContent, 800);
            
            // Hide intro content
            introContent.style.display = 'none';

            // Hide the big intro logo
            const introLogoContainer = document.querySelector('.intro-logo-container');
            if (introLogoContainer) {
                introLogoContainer.style.display = 'none';
            }

            // Show protocol list page
            introProtocolListPage.classList.add('visible');

            // Show header logo on protocol list page
            pageHeader.classList.add('protocol-list-active');
            
            // Skip sequence list - don't show it
            // await fadeIn(introSequenceContainer, 1000);
            // announceForScreenReader('Protocol sequence revealed: Field Diagnostic and 5 exit protocols');

            // Load and render protocol cards
            await loadAndRenderProtocolCards();

            // Fade in begin button
            await fadeIn(introBeginContainer, 1000);
        }

        // Continue button click handler
        introContinueBtn.addEventListener('click', () => {
            showProtocolListPage();
        });

        // Keyboard shortcut: Shift + Enter
        document.addEventListener('keydown', (e) => {
            if (e.shiftKey && e.key === 'Enter') {
                // Only trigger if continue button is visible and intro content is still showing
                if (introContinueContainer && 
                    parseFloat(window.getComputedStyle(introContinueContainer).opacity) > 0.5 &&
                    window.getComputedStyle(introContent).display !== 'none') {
                    e.preventDefault();
                    showProtocolListPage();
                }
            }
        });

        // Load protocols from API and render cards with progressive disclosure
        async function loadAndRenderProtocolCards() {
            try {
                const response = await fetch(`${API_BASE}/api/protocols`);
                const data = await response.json();

                if (data.protocols && data.protocols.length > 0) {
                    // Sort: Field Diagnostic first, then the 5 Field Exit protocols in order
                    const sortedProtocols = data.protocols.sort((a, b) => {
                        if (a.slug === 'field_diagnostic') return -1;
                        if (b.slug === 'field_diagnostic') return 1;
                        // Extract number from field_exit_protocol_N_...
                        const aNum = parseInt(a.slug.match(/field_exit_protocol_(\d+)/)?.[1] || '999');
                        const bNum = parseInt(b.slug.match(/field_exit_protocol_(\d+)/)?.[1] || '999');
                        return aNum - bNum;
                    }).slice(0, 6); // Take only the first 6

                    // Render each protocol card
                    for (const protocol of sortedProtocols) {
                        renderProtocolCard(protocol);
                    }

                    // Fade in the protocol deck
                    await fadeIn(introProtocolDeck, 1000);
                    announceForScreenReader('Protocol cards revealed. Use tab to navigate and explore each protocol.');
                }
            } catch (error) {
                console.error('Error loading protocols for intro:', error);
            }
        }

        // Render a single protocol card with progressive disclosure
        function renderProtocolCard(protocol) {
            const card = document.createElement('div');
            card.className = 'intro-protocol-card';

            // Title
            const title = document.createElement('div');
            title.className = 'intro-protocol-title';
            title.textContent = protocol.title;
            card.appendChild(title);

            // Use When section (initially hidden)
            const useWhenSection = document.createElement('div');
            useWhenSection.className = 'intro-disclosure-section';

            // Format use_when as a list if it's an array, otherwise as plain text
            let useWhenContent = '';
            if (Array.isArray(protocol.use_when)) {
                useWhenContent = '<ul>' + protocol.use_when.map(item => `<li>${item}</li>`).join('') + '</ul>';
            } else {
                useWhenContent = protocol.use_when || 'No use cases available';
            }

            useWhenSection.innerHTML = `
                <div class="intro-disclosure-label">Use This When</div>
                <div class="intro-disclosure-content">${useWhenContent}</div>
            `;
            card.appendChild(useWhenSection);

            // Use When button (initially visible)
            const useWhenBtn = document.createElement('button');
            useWhenBtn.className = 'intro-disclosure-btn';
            useWhenBtn.textContent = 'Use This When';
            useWhenBtn.setAttribute('aria-expanded', 'false');
            useWhenBtn.setAttribute('aria-controls', `usewhen-${protocol.id}`);
            useWhenSection.id = `usewhen-${protocol.id}`;
            card.appendChild(useWhenBtn);

            // Walk this Protocol button (initially hidden, shown after Use This When is clicked)
            const walkBtn = document.createElement('button');
            walkBtn.className = 'intro-walk-btn';
            walkBtn.textContent = 'Walk this Protocol';
            card.appendChild(walkBtn);

            // Handle Use This When button click
            useWhenBtn.addEventListener('click', () => {
                useWhenSection.classList.add('visible');
                useWhenBtn.style.display = 'none';
                useWhenBtn.setAttribute('aria-expanded', 'true');
                walkBtn.style.display = 'block';
                announceForScreenReader('Use This When revealed');
            });

            // Walk button handler - go to protocol entry view
            walkBtn.addEventListener('click', () => {
                // Add dissolving class to trigger border fade
                walkBtn.classList.add('dissolving');

                // Wait for border to dissolve (1.5s) then navigate
                setTimeout(() => {
                    // Scroll to top
                    window.scrollTo(0, 0);

                    // Set the selected protocol (needed for begin walk)
                    selectProtocol(protocol);

                    // Hide intro flow
                    introFlowView.classList.add('hidden');
                    
                    // Show content area
                    const contentArea = document.querySelector('.content-area');
                    if (contentArea) {
                        contentArea.classList.add('visible');
                    }
                    
                    // Remove intro-mode from header
                    const pageHeader = document.getElementById('page-header');
                    if (pageHeader) {
                        pageHeader.classList.remove('intro-mode');
                    }
                    
                    // Show entry view for this protocol
                    protocolSelectionView.classList.add('hidden');
                    entryView.classList.remove('hidden');
                    
                    // Update header
                    const headerTitle = document.querySelector('.header-title');
                    if (headerTitle) {
                        headerTitle.textContent = protocol.title;
                    }
                    
                    // Focus the entry input
                    entryInput.focus();
                    
                    // Scroll to top
                    window.scrollTo(0, 0);
                }, 1500);
            });

            introProtocolDeck.appendChild(card);
        }

        // Handle Begin button click
        introBeginBtn.addEventListener('click', () => {
            // Hide intro flow
            introFlowView.classList.add('hidden');
            
            // Show content area
            const contentArea = document.querySelector('.content-area');
            if (contentArea) {
                contentArea.classList.add('visible');
            }
            
            // Show protocol selection
            protocolSelectionView.classList.remove('hidden');
            
            // Remove intro-mode from header and update title
            const pageHeader = document.getElementById('page-header');
            if (pageHeader) {
                pageHeader.classList.remove('intro-mode');
            }
            
            const headerTitle = document.querySelector('.header-title');
            if (headerTitle) {
                headerTitle.textContent = 'Lichen Protocol';
            }
            
            // Scroll to top
            window.scrollTo(0, 0);
        });

        // Start the intro flow when page loads
        try {
            runIntroFlow().catch(error => {
                console.error('Error in intro flow:', error);
            });
        } catch (error) {
            console.error('Error starting intro flow:', error);
        }

        // ========================================
        // MAIN APP LOGIC
        // ========================================

        // Cost tracking (rough estimate)
        let estimatedCost = 0;
        function updateCostDisplay(increment = 0.01) {
            estimatedCost += increment;
            costDisplay.textContent = `$${estimatedCost.toFixed(3)}`;
        }

        // Loading indicator helpers
        function showLoadingIndicator() {
            if (headerCenterLogo) {
                headerCenterLogo.classList.add('spinning');
            }
        }

        function hideLoadingIndicator() {
            if (headerCenterLogo) {
                headerCenterLogo.classList.remove('spinning');
            }
        }

        // Fetch and display available protocols
        async function loadProtocols() {
            try {
                const response = await fetch(`${API_BASE}/api/protocols`);
                const data = await response.json();

                if (data.protocols && data.protocols.length > 0) {
                    renderProtocolCards(data.protocols);
                } else {
                    showError('No protocols available');
                }
            } catch (error) {
                console.error('Error loading protocols:', error);
                showError('Failed to load protocols. Please refresh the page.');
            }
        }

        // Render protocol cards
        function renderProtocolCards(protocols) {
            protocolGrid.innerHTML = '';

            // Sort protocols: Field Diagnostic first, then alphabetically by title
            const sortedProtocols = [...protocols].sort((a, b) => {
                if (a.slug === 'field_diagnostic') return -1;
                if (b.slug === 'field_diagnostic') return 1;
                return a.title.localeCompare(b.title);
            });

            sortedProtocols.forEach(protocol => {
                const card = document.createElement('div');
                card.className = 'protocol-card';

                // Truncate purpose if too long
                const purpose = protocol.purpose || 'No description available';
                const truncatedPurpose = purpose.length > 200
                    ? purpose.substring(0, 200) + '...'
                    : purpose;

                card.innerHTML = `
                    <div class="protocol-card-header">
                        <div class="protocol-card-title">${protocol.title}</div>
                        <div class="protocol-card-badge">${protocol.theme_count} themes</div>
                    </div>
                    <div class="protocol-card-purpose">${truncatedPurpose}</div>
                `;

                card.addEventListener('click', () => selectProtocol(protocol));
                protocolGrid.appendChild(card);
            });
        }

        // Handle protocol selection
        function selectProtocol(protocol) {
            selectedProtocol = protocol;

            // Scroll to top
            window.scrollTo(0, 0);

            // Update protocol title in entry view with stacked format
            // Split title at em dash (—) or long dash if present
            const title = protocol.title;
            if (title.includes('—')) {
                const parts = title.split('—');
                protocolTitle.innerHTML = `${parts[0].trim()}<br>${parts[1].trim()}`;
            } else if (title.includes(' — ')) {
                const parts = title.split(' — ');
                protocolTitle.innerHTML = `${parts[0].trim()}<br>${parts[1].trim()}`;
            } else {
                protocolTitle.textContent = title;
            }

            // Hide protocol selection, show entry view
            protocolSelectionView.classList.add('hidden');
            entryView.classList.remove('hidden');
        }

        // Detect platform for keyboard shortcuts
        const isMac = navigator.platform.toUpperCase().includes('MAC');

        // Load protocols on page load
        loadProtocols();

        // Set helper text based on platform
        responseHint.textContent = isMac ? 'Press ⌘ + Enter to continue' : 'Press Ctrl + Enter to continue';

        // Enable continue button when response has content
        responseInput.addEventListener('input', () => {
            continueButton.disabled = !responseInput.value.trim();
        });

        // Handle keyboard shortcuts for continue action
        responseInput.addEventListener('keydown', (e) => {
            const modifier = isMac ? e.metaKey : e.ctrlKey;

            // Cmd/Ctrl + Enter: trigger Continue or Ask Another Question
            if (modifier && e.key === 'Enter') {
                e.preventDefault();
                if (responseInput.value.trim()) {
                    // Check if we're in completion options mode
                    const askAnotherBtn = document.getElementById('ask-another-button');
                    if (askAnotherBtn && !askAnotherBtn.disabled) {
                        askAnotherBtn.click();
                    } else if (!continueButton.disabled) {
                        handleContinue();
                    }
                }
            }
            // Shift + Enter: allow new line (default behavior)
            // Enter alone: allow new line (default behavior)
        });

        // Begin walk
        beginButton.addEventListener('click', async () => {
            // Add clicked class to fade out border
            beginButton.classList.add('clicked');

            // Show loading indicator
            showLoadingIndicator();

            // Fade out main entry logo and title
            const title = entryView.querySelectorAll('div')[0];
            const logo = document.getElementById('lichen-logo');

            beginButton.disabled = true;

            // Fade out main logo and title
            if (logo) logo.classList.add('fade-out');
            if (title) title.classList.add('fade-out');

            // Wait for fade animations to complete
            await new Promise(resolve => setTimeout(resolve, 1200));

            try {
                const response = await fetch(`${API_BASE}/api/walk/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_input: 'begin',
                        protocol_slug: selectedProtocol?.slug
                    })
                });

                const data = await response.json();
                sessionId = data.session_id;
                protocolData = data;

                // Update cost display (ENTRY mode typically costs ~$0.01)
                updateCostDisplay(0.01);

                renderWalkState(data);

                // Hide loading indicator
                hideLoadingIndicator();
            } catch (error) {
                showError('The field lost connection. Please try again.');
                beginButton.textContent = 'Begin walk';
                beginButton.disabled = false;
                hideLoadingIndicator();
            }
        });

        // Show completion options (two buttons)
        function showCompletionOptions() {
            const walkControl = document.getElementById('walk-control');
            
            // Clear existing buttons
            walkControl.innerHTML = '';
            
            // Create two buttons
            const askAnotherBtn = document.createElement('button');
            askAnotherBtn.className = 'walk-button';
            askAnotherBtn.textContent = 'Ask Another Question';
            askAnotherBtn.id = 'ask-another-button';
            askAnotherBtn.style.marginRight = '1rem';
            
            const completeWalkBtn = document.createElement('button');
            completeWalkBtn.className = 'walk-button';
            completeWalkBtn.textContent = 'Complete Walk & View Summary';
            completeWalkBtn.id = 'complete-walk-button';
            
            walkControl.appendChild(askAnotherBtn);
            walkControl.appendChild(completeWalkBtn);
            
            // Handle ask another question
            askAnotherBtn.addEventListener('click', async () => {
                const userResponse = responseInput.value.trim();
                if (!userResponse) return;

                askAnotherBtn.classList.add('clicked');
                askAnotherBtn.disabled = true;
                responseInput.blur();

                // Show loading indicator
                showLoadingIndicator();

                try {
                    const response = await fetch(`${API_BASE}/api/walk/continue`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: sessionId,
                            user_response: userResponse
                        })
                    });

                    const data = await response.json();
                    protocolData = data;
                    updateCostDisplay(0.02);
                    responseInput.value = '';
                    renderWalkState(data);

                    // Hide loading indicator
                    hideLoadingIndicator();
                } catch (error) {
                    showError('The field lost connection. Please try again.');
                    askAnotherBtn.classList.remove('clicked');
                    askAnotherBtn.disabled = false;
                    hideLoadingIndicator();
                }
            });
            
            // Handle complete walk
            completeWalkBtn.addEventListener('click', async () => {
                completeWalkBtn.classList.add('clicked');
                completeWalkBtn.disabled = true;

                // Show loading indicator
                showLoadingIndicator();

                try {
                    const response = await fetch(`${API_BASE}/api/walk/complete`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: sessionId,
                            generate_summary: true
                        })
                    });

                    const data = await response.json();
                    protocolData = data;

                    // Update cost display for completion
                    updateCostDisplay(0.02);

                    renderWalkState(data);

                    // Hide loading indicator
                    hideLoadingIndicator();
                } catch (error) {
                    showError('The field lost connection. Please try again.');
                    completeWalkBtn.classList.remove('clicked');
                    completeWalkBtn.disabled = false;
                    hideLoadingIndicator();
                }
            });
        }

        // Continue walk handler function
        async function handleContinue() {
            const userResponse = responseInput.value.trim();
            if (!userResponse || !sessionId) return;

            // Add clicked class to fade out border
            continueButton.classList.add('clicked');

            // Blur input to stop cursor blinking
            responseInput.blur();

            continueButton.disabled = true;

            // Show loading indicator
            showLoadingIndicator();

            try {
                const response = await fetch(`${API_BASE}/api/walk/continue`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        user_response: userResponse
                    })
                });

                const data = await response.json();
                protocolData = data;

                // Update cost display (WALK responses typically cost ~$0.015-0.025)
                updateCostDisplay(0.02);

                responseInput.value = '';
                renderWalkState(data);

                continueButton.classList.remove('clicked');
                continueButton.disabled = false;

                // Hide loading indicator
                hideLoadingIndicator();

                // Focus will be set in renderWalkState after animation
            } catch (error) {
                showError('The field lost connection. Please try again.');
                continueButton.classList.remove('clicked');
                continueButton.disabled = false;
                hideLoadingIndicator();
            }
        }

        // Continue walk
        continueButton.addEventListener('click', handleContinue);

        // Handle generate report button (dynamically created after Theme 5)
        // Use event delegation since button is created dynamically
        document.addEventListener('click', async (e) => {
            if (e.target && e.target.id === 'generate-report-button') {
                const button = e.target;

                // Add clicked class to fade out border
                button.classList.add('clicked');
                button.disabled = true;

                // Show loading indicator
                showLoadingIndicator();

                try {
                    // Trigger CLOSE mode by sending "yes" to continue
                    const response = await fetch(`${API_BASE}/api/walk/continue`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: sessionId,
                            user_response: 'generate field diagnosis'
                        })
                    });

                    const data = await response.json();
                    protocolData = data;

                    // Update cost display (CLOSE mode costs ~$0.015)
                    updateCostDisplay(0.015);

                    renderWalkState(data);

                    // Hide loading indicator
                    hideLoadingIndicator();
                } catch (error) {
                    showError('The field lost connection. Please try again.');
                    button.classList.remove('clicked');
                    button.disabled = false;
                    hideLoadingIndicator();
                }
            }
        });

        // Render walk state
        async function renderWalkState(data) {
            console.log('🚀 renderWalkState called, mode:', data.mode);

            // Scroll to top whenever rendering walk state
            window.scrollTo(0, 0);

            // In ENTRY mode, stay in entry view but show protocol introduction
            if (data.mode === 'ENTRY') {
                console.log('📝 ENTRY mode - showing protocol introduction');

                headerState.textContent = 'Protocol Introduction';
                renderEntryResponse(data);
                return;
            }

            console.log('🎬 Starting WALK mode transition');

            // Update page header
            headerState.textContent = data.mode;
            
            // Handle undefined theme values gracefully
            const themeNum = data.theme_number || 1;
            const totalThemes = data.total_themes || 5;
            themePosition.textContent = `Theme ${themeNum} of ${totalThemes}`;

            // Parse and render composer output (but keep hidden)
            renderComposerOutput(data.composer_output);

            // Render supports - DISABLED
            // renderSupports(data);

            // supportsStrip.classList.add('active');

            // Hide entry view and show walk view
            entryView.style.display = 'none';
            walkView.style.opacity = '0';
            walkView.style.display = 'block';

            // Force reflow to ensure transition works
            walkView.offsetHeight;

            // Fade in everything
            walkView.style.opacity = '1';
            // supportsStrip.style.opacity = '1';

            // Add fade-in class to walk view children
            const walkChildren = walkView.querySelectorAll('.output-container, .response-area');
            walkChildren.forEach(child => {
                child.classList.add('fade-in-section');
            });

            // Apply jigsaw animation after fade-in is complete (skip for COMPLETE mode)
            if (data.mode !== 'COMPLETE') {
                setTimeout(() => {
                    const contentElements = composerOutput.querySelectorAll('.theme-title, .section-content');
                    contentElements.forEach(el => {
                        if (el.textContent.trim()) {
                            animateTextReveal(el);
                        }
                    });
                }, 100);
            }

            // Focus the response input after content is visible
            setTimeout(() => {
                responseInput.focus();
            }, 900);

            // Handle completion options (two buttons when final theme is complete)
            if (data.show_completion_options) {
                console.log('🎯 COMPLETION OPTIONS DETECTED - Showing two buttons');
                showCompletionOptions();
            }

            // Handle completion
            if (data.mode === 'COMPLETE') {
                console.log('🎯 COMPLETE MODE DETECTED - Starting completion handling');
                console.log('📋 Data received:', data);
                console.log('📄 Composer output length:', data.composer_output?.length);
                console.log('📄 Composer output preview:', data.composer_output?.substring(0, 200));

                headerState.textContent = `${data.protocol_name} Summary`;
                handleCompletion(data);
            }
        }

        // Animate text revealing randomly like a jigsaw puzzle
        function animateTextReveal(element, duration = 400) {
            const text = element.textContent;
            const words = text.split(/(\s+)/); // Split by whitespace but keep the spaces

            // Create spans for each word/space
            element.textContent = '';
            const spans = [];

            words.forEach(word => {
                if (word.trim() === '') {
                    // It's a space, add it directly
                    element.appendChild(document.createTextNode(word));
                } else {
                    // It's a word, wrap in span
                    const span = document.createElement('span');
                    span.textContent = word;
                    span.style.opacity = '0';
                    span.style.transition = 'opacity 0.2s ease-in';
                    span.style.display = 'inline';
                    element.appendChild(span);
                    spans.push(span);
                }
            });

            // Create random order for revealing
            const indices = spans.map((_, i) => i);
            for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }

            // Reveal words/letters in random order
            const totalSteps = Math.ceil(spans.length * 1.5); // More steps for variation
            const interval = duration / totalSteps;

            let revealed = 0;
            for (let step = 0; step < totalSteps && revealed < spans.length; step++) {
                setTimeout(() => {
                    if (revealed < spans.length) {
                        // Randomly decide: reveal full word (50%) or break into letters (50%)
                        if (Math.random() > 0.5) {
                            // Reveal full word
                            spans[indices[revealed]].style.opacity = '1';
                            revealed++;
                        } else {
                            // Break word into letters and reveal in random order
                            const span = spans[indices[revealed]];
                            const word = span.textContent;
                            const letters = word.split('');

                            span.textContent = '';
                            const letterSpans = letters.map(letter => {
                                const letterSpan = document.createElement('span');
                                letterSpan.textContent = letter;
                                letterSpan.style.opacity = '0';
                                letterSpan.style.transition = 'opacity 0.1s ease-in';
                                letterSpan.style.display = 'inline';
                                span.appendChild(letterSpan);
                                return letterSpan;
                            });

                            span.style.opacity = '1';

                            // Create random order for letters
                            const letterIndices = letters.map((_, i) => i);
                            for (let i = letterIndices.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [letterIndices[i], letterIndices[j]] = [letterIndices[j], letterIndices[i]];
                            }

                            // Reveal letters in random order
                            letterIndices.forEach((letterIndex, i) => {
                                setTimeout(() => {
                                    letterSpans[letterIndex].style.opacity = '1';
                                }, i * 40);
                            });

                            revealed++;
                        }
                    }
                }, step * interval);
            }
        }

        // Render ENTRY mode response (protocol introduction)
        function renderEntryResponse(data) {
            // Hide begin button
            beginButton.style.display = 'none';

            // Fade in header logo when protocol introduction loads
            if (headerCenterLogo) headerCenterLogo.classList.add('visible');

            // Hide the large logo completely, keep only header logo
            const logo = entryView.querySelector('img');
            const title = entryView.querySelector('div');
            if (logo) {
                logo.style.display = 'none';
            }
            if (title) {
                title.classList.remove('fade-out');
                title.classList.add('fade-in-only');
            }

            // Create response area in entry view (only if it doesn't exist)
            let entryResponseArea = document.getElementById('entry-response-area');
            if (!entryResponseArea) {
                entryResponseArea = document.createElement('div');
                entryResponseArea.id = 'entry-response-area';
                entryResponseArea.style.cssText = 'margin-top: 1rem; line-height: 1.7;';
            }

            // Parse JSON response from agent
            let entryData;
            try {
                entryData = JSON.parse(data.composer_output);
            } catch (e) {
                console.error('Failed to parse ENTRY response JSON:', e);
                showError('Failed to load protocol content');
                return;
            }

            const sectionData = entryData.sections;
            const firstThemeTitle = entryData.firstThemeTitle;

            // Helper function to format section content
            function formatSectionContent(content) {
                const lines = content.split('\n');
                let html = '';
                for (let line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed) continue;

                    if (trimmed.startsWith('- ') || trimmed.startsWith('• ')) {
                        html += `<div style="margin-left: 1.5rem; margin-bottom: 0.5rem; color: #292524;">${trimmed}</div>`;
                    } else {
                        html += `<div style="margin-bottom: 1rem; color: #292524; font-size: 1.0625rem;">${trimmed}</div>`;
                    }
                }
                return html;
            }

            // Show first section immediately
            if (sectionData.length > 0) {
                const firstSection = document.createElement('div');
                firstSection.className = 'fade-in-only';

                // Create title
                const titleDiv = document.createElement('div');
                titleDiv.style.cssText = 'font-size: 0.8125rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #78716C; margin-bottom: 0.75rem;';
                titleDiv.textContent = sectionData[0].title;
                firstSection.appendChild(titleDiv);

                // Create content container
                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = formatSectionContent(sectionData[0].content);

                // Hide all text content initially
                const textElements = contentDiv.querySelectorAll('div');
                textElements.forEach(el => {
                    el.style.opacity = '0';
                });

                firstSection.appendChild(contentDiv);
                entryResponseArea.appendChild(firstSection);

                // Apply jigsaw animation to all text in content immediately
                textElements.forEach(el => {
                    if (el.textContent.trim()) {
                        el.style.opacity = '1';
                        animateTextReveal(el);
                    }
                });
            }

            // Create buttons for remaining sections
            let currentIndex = 1;

            function showNextSection(event) {
                if (currentIndex < sectionData.length) {
                    const section = sectionData[currentIndex];

                    // Fade out the box by adding class to the clicked button
                    const button = event.target;
                    if (button) {
                        button.classList.add('revealed');

                        // After transition, add content and next button
                        setTimeout(() => {
                            // Create content container
                            const contentDiv = document.createElement('div');
                            contentDiv.innerHTML = formatSectionContent(section.content);

                            // Hide all text content initially
                            const textElements = contentDiv.querySelectorAll('div');
                            textElements.forEach(el => {
                                el.style.opacity = '0';
                            });

                            // Insert content after button
                            button.after(contentDiv);

                            // Apply jigsaw animation to all text in content immediately
                            textElements.forEach(el => {
                                if (el.textContent.trim()) {
                                    el.style.opacity = '1';
                                    animateTextReveal(el);
                                }
                            });

                            currentIndex++;

                            // Add next button or continue button
                            if (currentIndex < sectionData.length) {
                                addRevealButton(sectionData[currentIndex].title);
                            } else {
                                addContinueButton();
                            }
                        }, 500);
                    }
                }
            }

            function addRevealButton(nextTitle) {
                const btn = document.createElement('button');
                btn.className = 'section-reveal-btn fade-in-only section-reveal-button';
                btn.textContent = nextTitle;
                btn.onclick = showNextSection;

                entryResponseArea.appendChild(btn);
            }

            function addContinueButton() {
                const continueControl = document.createElement('div');
                continueControl.className = 'walk-control';
                continueControl.style.marginTop = '2rem';

                const continueBtn = document.createElement('button');
                continueBtn.className = 'walk-button fade-in-only';
                continueBtn.textContent = `Continue to Theme 1 – ${firstThemeTitle}`;
                continueBtn.onclick = async () => {
                    continueBtn.classList.add('clicked');
                    continueBtn.disabled = true;

                    // Show loading indicator
                    showLoadingIndicator();

                    try {
                        const response = await fetch(`${API_BASE}/api/walk/continue`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                session_id: sessionId,
                                user_response: 'yes'
                            })
                        });

                        const data = await response.json();
                        protocolData = data;

                        // Update cost display (initial walk start typically costs ~$0.02)
                        updateCostDisplay(0.02);

                        renderWalkState(data);

                        // Hide loading indicator
                        hideLoadingIndicator();
                    } catch (error) {
                        showError('The field lost connection. Please try again.');
                        continueBtn.classList.remove('clicked');
                        continueBtn.disabled = false;
                        hideLoadingIndicator();
                    }
                };

                continueControl.appendChild(continueBtn);
                entryResponseArea.appendChild(continueControl);
            }

            // Add first reveal button if there are more sections
            if (sectionData.length > 1) {
                addRevealButton(sectionData[1].title);
            } else {
                addContinueButton();
            }

            // Add to entry view
            entryView.appendChild(entryResponseArea);
        }

        // Render composer output
        // Convert markdown to HTML with improved parsing
        function convertMarkdownToHTML(markdown) {
            if (!markdown) return '';

            console.log('🔧 MARKDOWN INPUT (first 500 chars):', markdown.substring(0, 500));

            let html = markdown;

            // First, convert headers (before any other processing)
            // Support both ## and # formats
            html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^# (.+)$/gm, '<h2>$1</h2>');

            // Convert **bold text:** or **bold** to <strong>
            // Use a more robust pattern that handles multi-line
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

            // Convert bullet points
            html = html.replace(/^\• (.+)$/gm, '<li>$1</li>');
            html = html.replace(/^- (.+)$/gm, '<li>$1</li>');

            // Wrap consecutive <li> tags in <ul>
            html = html.replace(/(<li>.*?<\/li>\n?)+/gs, (match) => {
                return '<ul>' + match + '</ul>';
            });

            // Split into paragraphs based on double newlines first
            const paragraphs = html.split(/\n\n+/);
            const processed = [];

            for (let para of paragraphs) {
                const trimmed = para.trim();
                if (!trimmed) continue;

                // Check if it's already an HTML element
                if (trimmed.startsWith('<h2>') || trimmed.startsWith('<h3>') ||
                    trimmed.startsWith('<ul>') || trimmed.startsWith('<ol>') ||
                    trimmed.startsWith('<li>')) {
                    processed.push(trimmed);
                } else {
                    // Wrap plain text in paragraph tags
                    // Replace single newlines with spaces within paragraphs
                    const cleanText = trimmed.replace(/\n/g, ' ').replace(/\s+/g, ' ');
                    processed.push('<p>' + cleanText + '</p>');
                }
            }

            const result = processed.join('\n\n');
            console.log('🔧 FINAL HTML (first 500 chars):', result.substring(0, 500));
            console.log('🔧 Total processed elements:', processed.length);

            return result;
        }

        function renderComposerOutput(markdown) {
            composerOutput.innerHTML = '';

            console.log('📄 Composer output markdown:', markdown);

            // Parse markdown sections
            const sections = parseMarkdown(markdown);
            console.log('📋 Parsed sections:', sections);
            
            // Check if we should hide response area (protocol complete)
            const shouldHideResponseArea = sections.transition === 'PROTOCOL_COMPLETE';
            if (shouldHideResponseArea) {
                const responseArea = document.querySelector('.response-area');
                if (responseArea) responseArea.style.display = 'none';
                console.log('🎯 Hiding response area - protocol complete');
            } else {
                const responseArea = document.querySelector('.response-area');
                if (responseArea) responseArea.style.display = 'block';
            }

            // Render theme title if available
            if (sections.theme_name) {
                composerOutput.innerHTML += `
                    <div class="theme-title">${sections.theme_name}</div>
                `;
            }

            // Render based on available sections
            if (sections.orientation) {
                composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-label">Purpose</div>
                        <div class="section-content">${sections.orientation}</div>
                    </div>
                `;
            }

            if (sections.why_this_matters) {
                composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-label">Why This Matters</div>
                        <div class="section-content">${sections.why_this_matters}</div>
                    </div>
                `;
            }

            if (sections.guiding_question) {
                const label = sections.guiding_question.includes('•') ? 'Guiding Questions' : 'Guiding Question';
                composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-label">${label}</div>
                        <div class="section-content" style="white-space: pre-line;">${sections.guiding_question}</div>
                    </div>
                `;
            }

            if (sections.instruction) {
                composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-content" style="color: #78716C; font-style: italic; margin-top: 1.5rem;">${sections.instruction}</div>
                    </div>
                `;
            }

            if (sections.acknowledgment) {
                // Convert markdown to HTML for better formatting
                const htmlContent = convertMarkdownToHTML(sections.acknowledgment);
                console.log('📝 SETTING innerHTML with htmlContent');
                console.log('📝 htmlContent length:', htmlContent.length);
                composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-content">${htmlContent}</div>
                    </div>
                `;
                console.log('📝 composerOutput.innerHTML length after:', composerOutput.innerHTML.length);
                console.log('📝 composerOutput classes:', composerOutput.className);
            }

            if (sections.completion_prompt) {
                composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-label">Completion Prompt</div>
                        <div class="section-content" style="font-style: italic;">${sections.completion_prompt}</div>
                    </div>
                `;
            }

            if (sections.transition) {
                if (sections.transition === 'PROTOCOL_COMPLETE') {
                    // Special case: Show "Generate Report" button after completing all themes
                    const completionText = sections.completionText || 'You have completed all themes of this protocol.';
                    composerOutput.innerHTML += `
                        <div class="output-section">
                            <div class="section-content" style="color: #78716C; font-size: 1rem;">${completionText}</div>
                        </div>
                        <div class="output-section" style="margin-top: 2rem;">
                            <button id="generate-report-button" class="walk-button">Field Diagnosis Complete, generate report</button>
                        </div>
                    `;
                } else {
                    composerOutput.innerHTML += `
                        <div class="output-section">
                            <div class="section-content" style="color: #78716C; font-size: 1rem;">${sections.transition}</div>
                        </div>
                    `;
                }
            }
        }

        // Parse markdown into sections
        function parseMarkdown(markdown) {
            const sections = {};

            // Extract theme name from markdown (e.g., **Theme 1 – Surface Behaviors**)
            const themeMatch = markdown.match(/\*\*(Theme\s+\d+\s*[–—:-]\s*[^*]+)\*\*/i);
            if (themeMatch) sections.theme_name = themeMatch[1].trim();

            // ENTRY mode sections
            const purposeMatch = markdown.match(/\*\*Purpose\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
            if (purposeMatch) sections.orientation = purposeMatch[1].trim();

            const outcomesMatch = markdown.match(/\*\*Protocol-Level Outcomes\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
            if (outcomesMatch) sections.guiding_question = outcomesMatch[1].trim();

            // WALK mode sections - Purpose/Frame is the orientation
            const purposeWalkMatch = markdown.match(/\*\*Purpose:\*\*\s*([\s\S]*?)(?=\n\*\*|$)/i);
            if (purposeWalkMatch) sections.orientation = purposeWalkMatch[1].trim();

            const frameMatch = markdown.match(/\*\*Frame:\*\*\s*([\s\S]*?)(?=\n\*\*|$)/i);
            if (frameMatch) sections.orientation = frameMatch[1].trim();

            const orientationMatch = markdown.match(/\*\*Orientation\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
            if (orientationMatch) sections.orientation = orientationMatch[1].trim();

            // Guiding Questions (plural) - extract the bullet points
            const questionsMatch = markdown.match(/\*\*Guiding Questions:\*\*\s*\n([\s\S]*?)(?=\n\n[^•\n]|\n\*\*|$)/i);
            if (questionsMatch) {
                sections.guiding_question = questionsMatch[1].trim();
            }

            // Guiding Question (singular)
            const questionMatch = markdown.match(/\*\*Guiding Question\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
            if (questionMatch) sections.guiding_question = questionMatch[1].trim();

            // Common sections
            const whyMatch = markdown.match(/\*\*Why This Matters\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
            if (whyMatch) sections.why_this_matters = whyMatch[1].trim();

            // CLOSE mode - field diagnosis content
            // Check if this is completion content by looking for common CLOSE mode patterns
            // Updated to handle both Field Diagnostic and Field Exit protocols
            if (markdown.includes("field I'd call") ||
                markdown.includes("You've completed") ||
                markdown.includes("**FIELD DIAGNOSIS**") ||
                markdown.includes("**Pattern Identified:**") ||
                markdown.includes("**Type:**") ||
                (markdown.includes("**") && markdown.length > 200 && !markdown.includes("Purpose:"))) {
                // For CLOSE mode, treat the entire content as acknowledgment/diagnosis
                sections.acknowledgment = markdown.trim();
                return sections;
            }

            // Interpretation section (with invisible marker like <!-- INTERPRETATION -->)
            const interpretationMatch = markdown.match(/<!--\s*INTERPRETATION\s*-->\s*\n([\s\S]*?)(?=\n(?:<!--|\*\*)|$)/i);
            if (interpretationMatch) {
                sections.acknowledgment = interpretationMatch[1].trim();
            }

            // Acknowledgment/Interpretation - fallback to capture from "I hear you" or "I see you" until completion prompt or transition
            if (!sections.acknowledgment) {
                const ackMatch = markdown.match(/^(I (?:hear|see) you[\s\S]*?)(?=\n\*\*Completion Prompt\*\*|Ready to move|Shall we move|\n\*\*Theme)/im);
                if (ackMatch) sections.acknowledgment = ackMatch[1].trim();
            }

            const promptMatch = markdown.match(/\*\*Completion Prompt\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
            if (promptMatch) sections.completion_prompt = promptMatch[1].trim();

            // Check for protocol completion (any protocol, any number of themes)
            const completionMatch = markdown.match(/You've completed all \d+ themes of the .+/i);
            if (completionMatch) {
                sections.transition = 'PROTOCOL_COMPLETE';
                sections.completionText = completionMatch[0]; // Store the actual completion text
            } else {
                // Check for "Ready to move into Theme X" pattern
                const readyMatch = markdown.match(/Ready to move into \*\*(Theme \d+[^*]*)\*\*\??/i);
                if (readyMatch) sections.transition = `Ready to move into <strong>${readyMatch[1]}</strong>?`;

                // Check for "Shall we move into Theme X" pattern (older)
                const shallMatch = markdown.match(/Shall we move into \*\*(Theme \d+[^*]*)\*\*\??/i);
                if (shallMatch) sections.transition = `Shall we move into <strong>${shallMatch[1]}</strong>?`;
            }

            // Also check for "Would you like me to" pattern (ENTRY mode)
            const wouldYouMatch = markdown.match(/(Would you like me to.*?\*\*Theme \d+[^*]*\*\*\??)/i);
            if (wouldYouMatch) sections.transition = wouldYouMatch[1];

            // Extract final instruction like "Take a moment..."
            const instructionMatch = markdown.match(/\n\n([A-Z][^*\n]+(?:moment|ready)[^*\n]+\.)/);
            if (instructionMatch) sections.instruction = instructionMatch[1].trim();

            return sections;
        }

        // Render supports - DISABLED
        /* function renderSupports(data) {
            supportsContainer.innerHTML = `<div class="supports-label">Supports (1)</div>`;

            const card = document.createElement('div');
            card.className = 'support-card';
            card.innerHTML = `
                <div class="support-header">
                    <div class="support-source">${data.protocol_name}</div>
                    <div class="support-theme">Theme ${data.theme_number}</div>
                </div>
                <div class="support-body">
                    <div class="support-content">${data.composer_output.substring(0, 300)}...</div>
                </div>
            `;

            card.addEventListener('click', () => {
                card.querySelector('.support-body').classList.toggle('expanded');
            });

            supportsContainer.appendChild(card);
        } */

        // Handle completion
        function handleCompletion(data) {
            console.log('🔧 handleCompletion called');
            console.log('📋 Data in handleCompletion:', data);

            // Add wider container class for summary mode
            const fieldContainer = document.getElementById('main-content');
            if (fieldContainer) {
                fieldContainer.classList.add('summary-container');
            }

            // Render the completion content (field diagnosis and summary)
            console.log('🎨 Rendering composer output...');
            renderComposerOutput(data.composer_output);

            // Add summary-mode class for enhanced styling
            console.log('🔧 Before adding summary-mode, classes:', composerOutput.className);
            composerOutput.classList.add('summary-mode');
            console.log('🔧 After adding summary-mode, classes:', composerOutput.className);

            // Log the actual HTML structure
            console.log('🔧 Composer output HTML (first 500 chars):', composerOutput.innerHTML.substring(0, 500));

            // Check if h2 tags exist
            const h2Tags = composerOutput.querySelectorAll('h2');
            console.log('🔧 Number of h2 tags found:', h2Tags.length);
            if (h2Tags.length > 0) {
                console.log('🔧 First h2 text:', h2Tags[0].textContent);
                console.log('🔧 First h2 computed style font-size:', window.getComputedStyle(h2Tags[0]).fontSize);
                console.log('🔧 First h2 computed style color:', window.getComputedStyle(h2Tags[0]).color);
            }

            console.log('✅ Composer output rendered with summary styling');
            
            // Hide the entire response area (input + continue button)
            const responseArea = document.querySelector('.response-area');
            console.log('🔍 Response area found:', !!responseArea);
            if (responseArea) {
                console.log('👁️ Hiding response area');
                responseArea.style.display = 'none';
                console.log('✅ Response area hidden');
            } else {
                console.log('⚠️ Response area not found!');
            }
            
            // Hide the existing continue button specifically
            const continueButton = document.getElementById('continue-button');
            console.log('🔍 Continue button found:', !!continueButton);
            if (continueButton) {
                console.log('👁️ Hiding continue button');
                continueButton.style.display = 'none';
                console.log('✅ Continue button hidden');
            } else {
                console.log('⚠️ Continue button not found!');
            }
            
            // Add completion button container after composer output
            console.log('🔨 Creating completion buttons...');
            const completionContainer = document.createElement('div');
            completionContainer.className = 'walk-control';
            completionContainer.style.marginTop = '3rem';
            completionContainer.style.display = 'flex';
            completionContainer.style.gap = '1rem';
            completionContainer.style.justifyContent = 'center';
            completionContainer.style.paddingTop = '2rem';
            completionContainer.style.borderTop = '1px solid #E7E5E4';
            completionContainer.innerHTML = `
                <button class="walk-button" id="download-button" style="padding: 0.875rem 1.75rem; font-size: 0.9375rem;">Download Summary</button>
                <button class="walk-button" id="completion-button" style="padding: 0.875rem 1.75rem; font-size: 0.9375rem;">Mark complete</button>
            `;
            
            // Insert completion button after composer output
            console.log('🔍 Composer output parent:', !!composerOutput.parentNode);
            composerOutput.parentNode.insertBefore(completionContainer, composerOutput.nextSibling);
            console.log('✅ Completion buttons added');
            
            // Handle download button click
            const downloadButton = completionContainer.querySelector('#download-button');
            console.log('🔍 Download button found:', !!downloadButton);
            downloadButton.onclick = async () => {
                console.log('🖱️ Download button clicked');

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                const timestamp = new Date().toLocaleString();
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const margin = 20;
                const maxWidth = pageWidth - (margin * 2);
                let yPosition = margin;

                // Load and add logo
                const logoImg = document.querySelector('img[src="/lichen-logo.png"]');
                if (logoImg) {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = logoImg.width;
                    canvas.height = logoImg.height;
                    ctx.drawImage(logoImg, 0, 0);
                    const logoData = canvas.toDataURL('image/png');

                    // Add logo at top center (20mm wide, proportional height)
                    const logoWidth = 20;
                    const logoHeight = (logoImg.height / logoImg.width) * logoWidth;
                    const logoX = (pageWidth - logoWidth) / 2;
                    doc.addImage(logoData, 'PNG', logoX, yPosition, logoWidth, logoHeight);
                    yPosition += logoHeight + 10;
                }

                // Helper function to add footer to each page
                const addFooter = () => {
                    const currentDate = new Date().toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    doc.setFontSize(8);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(160, 160, 160); // Subtle gray
                    doc.text(currentDate, margin, pageHeight - 10);
                    doc.setTextColor(0, 0, 0); // Reset to black
                };

                // Add footer to first page
                addFooter();

                // Helper function to add text with word wrapping
                const addText = (text, fontSize, isBold = false, isItalic = false) => {
                    if (yPosition > pageHeight - 25) {
                        doc.addPage();
                        addFooter(); // Add footer to new page
                        yPosition = margin;
                    }

                    doc.setFontSize(fontSize);
                    if (isBold && isItalic) {
                        doc.setFont('helvetica', 'bolditalic');
                    } else if (isBold) {
                        doc.setFont('helvetica', 'bold');
                    } else if (isItalic) {
                        doc.setFont('helvetica', 'italic');
                    } else {
                        doc.setFont('helvetica', 'normal');
                    }

                    const lines = doc.splitTextToSize(text, maxWidth);
                    lines.forEach(line => {
                        if (yPosition > pageHeight - 25) {
                            doc.addPage();
                            addFooter(); // Add footer to new page
                            yPosition = margin;
                        }
                        doc.text(line, margin, yPosition);
                        yPosition += fontSize * 0.5;
                    });
                };

                // Title
                addText(data.protocol_name.toUpperCase(), 18, true);
                yPosition += 5;
                addText('Summary Report', 14, false, true);
                yPosition += 10;

                // Draw a line
                doc.setDrawColor(200);
                doc.line(margin, yPosition, pageWidth - margin, yPosition);
                yPosition += 10;

                // Get the text content and parse it
                const summaryText = composerOutput.innerText || composerOutput.textContent;
                const lines = summaryText.split('\n');

                for (let line of lines) {
                    const trimmed = line.trim();
                    if (!trimmed) {
                        yPosition += 3;
                        continue;
                    }

                    // Check if it's a header (all caps or starts with specific patterns)
                    if (trimmed.match(/^[A-Z\s]{5,}$/) || trimmed.match(/^(FIELD DIAGNOSIS|SUMMARY|THE FIELD)/)) {
                        yPosition += 5;
                        addText(trimmed, 14, true);
                        yPosition += 5;
                    } else if (trimmed.includes('**') || trimmed.match(/^[A-Z][A-Z\s]+:/)) {
                        // Bold text or section headers
                        const cleanText = trimmed.replace(/\*\*/g, '');
                        addText(cleanText, 11, true);
                        yPosition += 2;
                    } else {
                        // Regular paragraph text
                        addText(trimmed, 10);
                        yPosition += 2;
                    }
                }

                // Save the PDF
                const protocolSlug = data.protocol_name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
                const date = new Date().toISOString().split('T')[0];
                doc.save(`${protocolSlug}-${date}.pdf`);

                console.log('✅ Summary downloaded as PDF');
            };
            
            // Handle completion button click
            const button = completionContainer.querySelector('#completion-button');
            console.log('🔍 Completion button found:', !!button);
            button.onclick = async () => {
                console.log('🖱️ Completion button clicked');
                
                // Add clicked class to fade out border
                button.classList.add('clicked');
                
                const overlay = document.getElementById('completion-overlay');
                overlay.classList.add('active');

                setTimeout(async () => {
                    overlay.classList.remove('active');
                    
                    // Call complete endpoint
                    await fetch(`${API_BASE}/api/walk/complete`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: sessionId,
                            generate_summary: false
                        })
                    });

                    // Reset to entry
                    location.reload();
                }, 4000);
            };
            
            console.log('🎉 handleCompletion completed');
        }

        // Show error
        function showError(message) {
            errorMessage.textContent = message;
            errorStrip.classList.add('active');
            setTimeout(() => errorStrip.classList.remove('active'), 5000);
        }
    </script>
</body>
</html>