<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lichen Field</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <!-- CSS Stylesheets -->
    <link rel="stylesheet" href="/assets/css/base.css" />
    <link rel="stylesheet" href="/assets/css/animations.css" />
    <link rel="stylesheet" href="/assets/css/layout.css" />
    <link rel="stylesheet" href="/assets/css/components.css" />
    <link rel="stylesheet" href="/assets/css/views.css" />
    <link rel="stylesheet" href="/assets/css/responsive.css" />
  </head>
  <body>
    <!-- Page Header -->
    <div class="page-header intro-mode" id="page-header">
      <div class="header-title">Lichen</div>
      <img src="/lichen-logo.png" alt="" class="header-center-logo" id="header-center-logo" />
      <div class="header-logo-badge" id="memory-layer-badge" data-dev-badge>Memory Layer Dev</div>
      <div class="header-state" id="header-state">Entry</div>
      <div class="theme-position" id="theme-position"></div>
      <div class="cost-display" id="cost-display">$0.00</div>
      <div class="branch-label" id="branch-label">loading...</div>
    </div>

    <!-- State Header (legacy - for walk mode) -->
    <div class="state-header" id="state-header" style="display: none">
      <div class="mode-indicator" id="mode-indicator">Entry</div>
      <div class="protocol-name" id="protocol-name"></div>
    </div>

    <!-- Screen reader announcements -->
    <div
      class="sr-only"
      role="status"
      aria-live="polite"
      aria-atomic="true"
      id="sr-announcer"
    ></div>

    <!-- Intro Flow View -->
    <div class="intro-flow-view" id="intro-flow-view">
      <!-- Spinning Logo -->
      <div class="intro-logo-container">
        <img src="/lichen-logo.png" alt="Lichen" class="logo-spin-intro" id="intro-logo" />
        <div class="header-logo-badge" style="transform: translate(-10px, 36px)" data-dev-badge>
          Memory Layer Dev
        </div>
      </div>

      <div class="intro-content" id="intro-content">
        <!-- Quote - Desktop Version -->
        <div class="intro-quote desktop-only" id="intro-quote-desktop">
          "The field is the sole governing agency of the particle."
        </div>

        <!-- Quote - Mobile Version (Inline Attribution) -->
        <div class="intro-quote mobile-only" id="intro-quote-mobile">
          "The field is the sole governing agency of the particle." â€” Albert Einstein
        </div>

        <!-- Embodiment Lines -->
        <div id="intro-embodiment-lines"></div>

        <!-- Orientation (hidden) -->
        <div class="intro-orientation" id="intro-orientation" style="display: none">
          Orientation with the system is six protocols long
        </div>

        <!-- Continue Button (shown after orientation) -->
        <div class="intro-continue-container" id="intro-continue-container">
          <button class="intro-continue-btn" id="intro-continue-btn">Continue</button>
          <div class="intro-continue-hint">Press Shift + Enter or âŒ˜/Ctrl + Enter</div>
        </div>
      </div>

      <!-- Protocol List Page (shown after Continue) -->
      <div class="intro-protocol-list-page" id="intro-protocol-list-page">
        <!-- Protocol Guidance -->
        <div class="intro-protocol-guidance" id="intro-protocol-guidance">
          <p>
            The Field Exit Protocols are meant to be walked in order, as each one supports the
            nextâ€”from identifying the field you're in, to releasing its residue, closing it with
            integrity, and learning to hold a new one. Following the full sequence provides the most
            complete process of change.
          </p>
          <p>
            However, the protocols can also be used individually. You can read the "Use this whenâ€¦"
            section and begin with whichever one feels most relevant. What matters is that you
            engage honestly with the process, in whatever order makes sense for you.
          </p>
        </div>

        <!-- Sequence List -->
        <div class="intro-sequence-container" id="intro-sequence-container">
          <ul class="intro-sequence-list">
            <li class="intro-sequence-item prelude">Field Diagnostic (prelude)</li>
            <li class="intro-sequence-item" data-number="1.">Knowing When a Field Must End</li>
            <li class="intro-sequence-item" data-number="2.">Composting the Old Signal</li>
            <li class="intro-sequence-item" data-number="3.">
              Extracting the Gifts Without Carrying the Pattern
            </li>
            <li class="intro-sequence-item" data-number="4.">Designing a Clean Exit</li>
            <li class="intro-sequence-item" data-number="5.">Walking Forward Without Residue</li>
          </ul>
          <div class="intro-sequence-subtext">
            Each stage opens the next. You will be guided, one step at a time.
          </div>
        </div>

        <!-- Protocol Deck -->
        <div class="intro-protocol-deck" id="intro-protocol-deck">
          <!-- Protocol cards will be populated by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="content-area">
      <div class="field-container" id="main-content">
        <!-- Protocol Selection View -->
        <div class="protocol-selection-view hidden" id="protocol-selection-view">
          <div class="protocol-selection-header">
            <img
              src="/lichen-logo.png"
              alt="Lichen"
              style="height: 80px; width: auto; margin-bottom: 2rem"
            />
            <div
              class="header-logo-badge"
              style="transform: translate(60px, -40px); font-size: 0.95rem"
              data-dev-badge
            >
              Memory Layer Dev
            </div>
            <div class="protocol-selection-title">Choose Your Protocol</div>
            <div class="protocol-selection-subtitle">Select a protocol to begin your walk</div>
          </div>
          <div class="protocol-grid" id="protocol-grid">
            <!-- Protocol cards will be populated by JavaScript -->
          </div>
        </div>

        <!-- Entry View -->
        <div class="entry-view hidden" id="entry-view">
          <img
            src="/lichen-logo.png"
            alt="Lichen"
            id="lichen-logo"
            style="height: 80px; width: auto; margin-bottom: 2rem"
          />
          <div
            class="header-logo-badge"
            style="transform: translate(60px, -40px); font-size: 0.95rem"
            data-dev-badge
          >
            Memory Layer Dev
          </div>

          <script>
            // Show Memory Layer Dev badges only when explicitly requested.
            (function () {
              try {
                const urlParams = new URLSearchParams(window.location.search);
                const devParam = urlParams.get('dev');
                const localFlag = localStorage.getItem('showMemoryLayerBadge');
                const shouldShow = devParam === 'memory-layer' || localFlag === 'true';

                document.querySelectorAll('[data-dev-badge]').forEach((el) => {
                  if (el && el.style) el.style.display = shouldShow ? 'block' : 'none';
                });
              } catch (e) {
                // Fail silently
              }
            })();
          </script>
          <div
            id="protocol-title"
            style="
              font-size: 1.5rem;
              font-weight: 500;
              color: #78716c;
              margin-bottom: 3rem;
              text-align: center;
              line-height: 1.4;
              cursor: pointer;
              transition: color 0.2s ease;
            "
            title="Click to expand all sections"
          >
            Field Diagnostic Protocol
          </div>
          <button class="walk-button" id="begin-button">Begin walk</button>
        </div>

        <!-- Walk View (hidden initially) -->
        <div id="walk-view" style="display: none; transition: opacity 0.8s ease-out">
          <!-- Error Strip -->
          <div class="error-strip" id="error-strip">
            <div class="error-message" id="error-message"></div>
          </div>

          <!-- Composer Output -->
          <div class="composer-output" id="composer-output"></div>

          <!-- Response Area -->
          <div class="response-area">
            <textarea
              class="response-input"
              id="response-input"
              placeholder="Your response..."
              rows="3"
            ></textarea>
            <div class="response-hint" id="response-hint"></div>

            <div class="walk-control" id="walk-control">
              <button
                class="walk-button"
                id="continue-button"
                disabled
                aria-label="Continue (Ctrl or Cmd + Enter)"
              >
                <svg
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  style="display: block; margin: 0 auto"
                >
                  <polyline points="18 15 12 9 6 15"></polyline>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Supports Strip - DISABLED -->
    <!-- <div class="supports-strip" id="supports-strip">
        <div class="supports-container" id="supports-container"></div>
    </div> -->

    <!-- Completion Overlay -->
    <div class="completion-overlay" id="completion-overlay">
      <div class="completion-message">
        <div class="completion-title" id="overlay-title">Protocol complete.</div>
        <div class="completion-subtitle" id="overlay-subtitle">The field rests.</div>
      </div>
    </div>

    <script type="module">
      // API Integration - automatically detects environment
      const API_BASE =
        window.location.hostname === 'localhost'
          ? `http://localhost:${window.location.port || 3000}`
          : ''; // Use relative URLs for production (same origin)

      // API Key for authentication (set to null for local dev if X_API_KEY not required)
      const API_KEY =
        window.location.hostname === 'localhost'
          ? null // Set to your local key if needed, or null to skip validation
          : 'lichen-field-2025-secret'; // Replace with your Railway X_API_KEY

      let sessionId = null;
      let currentMode = 'ENTRY';
      let protocolData = null;
      let selectedProtocol = null; // Store selected protocol

      // Helper function to build headers with API key
      function getHeaders() {
        const headers = {
          'Content-Type': 'application/json',
        };
        if (API_KEY) {
          headers['X-API-Key'] = API_KEY;
        }
        return headers;
      }

      // DOM Elements - Intro Flow
      const introFlowView = document.getElementById('intro-flow-view');
      const introLogo = document.getElementById('intro-logo');
      const introQuoteDesktop = document.getElementById('intro-quote-desktop');
      const introQuoteMobile = document.getElementById('intro-quote-mobile');
      const introEmbodimentLines = document.getElementById('intro-embodiment-lines');
      const introOrientation = document.getElementById('intro-orientation');
      const introContinueContainer = document.getElementById('intro-continue-container');
      const introContinueBtn = document.getElementById('intro-continue-btn');
      const introContent = document.getElementById('intro-content');
      const introProtocolListPage = document.getElementById('intro-protocol-list-page');
      const introSequenceContainer = document.getElementById('intro-sequence-container');
      const introProtocolDeck = document.getElementById('intro-protocol-deck');
      const introProtocolGuidance = document.getElementById('intro-protocol-guidance');
      const introBeginContainer = document.getElementById('intro-begin-container');
      const introBeginBtn = document.getElementById('intro-begin-btn');
      const srAnnouncer = document.getElementById('sr-announcer');

      // Intro animation control
      let skipIntroAnimations = false;

      // DOM Elements - Main App
      const protocolSelectionView = document.getElementById('protocol-selection-view');
      const protocolGrid = document.getElementById('protocol-grid');
      const protocolTitle = document.getElementById('protocol-title');
      const entryView = document.getElementById('entry-view');
      const walkView = document.getElementById('walk-view');
      const entryInput = document.getElementById('entry-input');
      const beginButton = document.getElementById('begin-button');
      const responseInput = document.getElementById('response-input');
      const continueButton = document.getElementById('continue-button');
      const pageHeader = document.getElementById('page-header');
      const headerState = document.getElementById('header-state');
      const headerCenterLogo = document.getElementById('header-center-logo');
      const stateHeader = document.getElementById('state-header');
      const modeIndicator = document.getElementById('mode-indicator');
      const protocolName = document.getElementById('protocol-name');
      const themePosition = document.getElementById('theme-position');
      const composerOutput = document.getElementById('composer-output');
      // const supportsStrip = document.getElementById('supports-strip');
      // const supportsContainer = document.getElementById('supports-container');
      const errorStrip = document.getElementById('error-strip');
      const errorMessage = document.getElementById('error-message');
      const responseHint = document.getElementById('response-hint');
      const costDisplay = document.getElementById('cost-display');
      const branchLabel = document.getElementById('branch-label');

      // Fetch and display current git branch
      async function fetchBranch() {
        try {
          const response = await fetch(`${API_BASE}/api/branch`);
          const data = await response.json();
          if (branchLabel && data.branch) {
            branchLabel.textContent = `branch: ${data.branch}`;
          } else {
            console.error('Branch data missing:', data);
            if (branchLabel) branchLabel.textContent = 'branch: unknown';
          }
        } catch (error) {
          console.error('Error fetching branch:', error);
          if (branchLabel) {
            branchLabel.textContent = 'branch: error';
          }
        }
      }

      // Fetch branch on page load
      fetchBranch();

      // Detect platform for keyboard shortcuts
      const isMac = navigator.platform.toUpperCase().includes('MAC');

      // Set platform-specific keyboard shortcut hints
      const introContinueHint = document.querySelector('.intro-continue-hint');
      if (introContinueHint) {
        introContinueHint.textContent = isMac ? 'Press âŒ˜ + Enter' : 'Press Ctrl + Enter';
      }

      // ========================================
      // INTRO FLOW LOGIC
      // ========================================

      // Timing constants (tunable)
      const TIMING = {
        initialWait: 2000, // 2s wait before first line
        jigsawDuration: 400, // 0.4s jigsaw animation
        lineDuration: 3000, // 3s line stays visible
        fadeOutDuration: 1000, // 1s fade out
        beforeOrientation: 1200, // 1.2s pause before orientation
        beforeSequence: 1700, // 1.7s pause before sequence
      };

      // Check for reduced motion preference
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Announce text for screen readers
      function announceForScreenReader(text) {
        if (srAnnouncer) {
          srAnnouncer.textContent = text;
          setTimeout(() => {
            srAnnouncer.textContent = '';
          }, 1000);
        }
      }

      // Fade in an element (opacity only)
      function fadeIn(element, duration = 1000) {
        return new Promise((resolve) => {
          if (!element) {
            resolve();
            return;
          }
          element.style.transition = `opacity ${duration}ms ease`;
          element.style.opacity = '1';
          setTimeout(resolve, duration);
        });
      }

      // Fade in with forced text reset (for intro flow only)
      function fadeInClean(element, duration = 1000) {
        return new Promise((resolve) => {
          if (!element) {
            resolve();
            return;
          }
          // Force clean text content (strips any spans)
          const text = element.textContent;
          element.textContent = text;

          element.style.transition = `opacity ${duration}ms ease`;
          element.style.opacity = '1';
          setTimeout(resolve, duration);
        });
      }

      // Fade out an element
      function fadeOut(element, duration = TIMING.fadeOutDuration) {
        return new Promise((resolve) => {
          if (!element) {
            resolve();
            return;
          }
          element.style.transition = `opacity ${duration}ms ease`;
          element.style.opacity = '0';
          setTimeout(resolve, duration);
        });
      }

      // Organically reveal all intro text with quick, staggered transitions
      async function revealAllIntroText() {
        skipIntroAnimations = true;

        // Reset text content for both desktop and mobile quotes (with inline attribution)
        introQuoteDesktop.textContent =
          '"The field is the sole governing agency of the particle." â€” Albert Einstein';
        introQuoteMobile.textContent =
          '"The field is the sole governing agency of the particle." â€” Albert Einstein';

        // Show quotes with quick fade
        introQuoteDesktop.style.transition = 'opacity 300ms ease';
        introQuoteDesktop.style.opacity = '1';
        introQuoteDesktop.style.color = '';

        introQuoteMobile.style.transition = 'opacity 300ms ease';
        introQuoteMobile.style.opacity = '1';
        introQuoteMobile.style.color = '';

        // Wait a moment before showing embodiment lines
        await new Promise((resolve) => setTimeout(resolve, 150));

        // Create and show all embodiment lines with staggered quick fades
        const embodimentLines = [
          'You are the particle.',
          "Every decision, every signal, every relationship is shaped by the field you're in.",
          'The Lichen System listens to that field.',
          'It helps you see where you are.',
          'It helps you transform the field when the time is right.',
        ];

        // Clear any existing lines
        introEmbodimentLines.innerHTML = '';

        // Add all lines with quick staggered reveals
        for (let i = 0; i < embodimentLines.length; i++) {
          const line = document.createElement('div');
          line.className = 'intro-text-line';
          line.textContent = embodimentLines[i];
          line.style.top = `calc(33% - 70px + ${60 + i * 40}px)`;
          line.style.transition = 'opacity 250ms ease';
          line.style.opacity = '0';
          line.style.color = '';
          introEmbodimentLines.appendChild(line);

          // Quick stagger (100ms between each line)
          await new Promise((resolve) => setTimeout(resolve, 100));
          line.style.opacity = '1';
        }

        // Show continue button with final quick fade
        await new Promise((resolve) => setTimeout(resolve, 100));
        introContinueContainer.style.transition = 'opacity 300ms ease';
        introContinueContainer.style.opacity = '1';
      }

      // Run the intro flow sequence
      async function runIntroFlow() {
        console.log('Starting intro flow...');
        console.log('introQuoteDesktop element:', introQuoteDesktop);
        console.log('introQuoteMobile element:', introQuoteMobile);
        console.log('introEmbodimentLines element:', introEmbodimentLines);

        // Reset all text to plain text for both desktop and mobile versions
        if (introQuoteDesktop) {
          introQuoteDesktop.textContent =
            '"The field is the sole governing agency of the particle." â€” Albert Einstein';
        }
        if (introQuoteMobile) {
          introQuoteMobile.textContent =
            '"The field is the sole governing agency of the particle." â€” Albert Einstein';
        }

        // Check if animations should be skipped
        if (skipIntroAnimations) {
          return; // Exit early, text already revealed
        }

        // 1. Wait 2 seconds with logo visible and spinning
        await new Promise((resolve) => setTimeout(resolve, TIMING.initialWait));
        console.log('Initial wait complete, showing quote...');

        // Check if animations were skipped during the wait
        if (skipIntroAnimations) {
          return; // Exit early if user clicked logo
        }

        // 2. Show quote with simple fade (0.86s) - both desktop and mobile versions
        // The CSS will handle showing only the appropriate version
        if (introQuoteDesktop && introQuoteMobile) {
          // Fade in both versions (CSS controls which one is visible)
          await Promise.all([
            fadeInClean(introQuoteDesktop, 860),
            fadeInClean(introQuoteMobile, 860),
          ]);

          // Announce for screen readers (use desktop version text)
          announceForScreenReader(
            '"The field is the sole governing agency of the particle." â€” Albert Einstein'
          );

          // Wait 3 seconds total before greying out
          await new Promise((resolve) => setTimeout(resolve, 3000));

          // Check if animations were skipped during the wait
          if (skipIntroAnimations) {
            return; // Exit early if user clicked logo
          }

          // Grey out both versions
          introQuoteDesktop.style.transition = 'opacity 500ms ease, color 500ms ease';
          introQuoteDesktop.style.opacity = '0.6';
          introQuoteDesktop.style.color = '#78716C';

          introQuoteMobile.style.transition = 'opacity 500ms ease, color 500ms ease';
          introQuoteMobile.style.opacity = '0.6';
          introQuoteMobile.style.color = '#78716C';

          await new Promise((resolve) => setTimeout(resolve, 500)); // Wait for grey transition

          console.log('Quote complete');
        } else {
          console.error('Quote elements not found!');
        }

        // 3. Show each embodiment line with jigsaw fade, one at a time
        const embodimentLines = [
          'You are the particle.',
          "Every decision, every signal, every relationship is shaped by the field you're in.",
          'The Lichen System listens to that field.',
          'It helps you see where you are.',
          'It helps you transform the field when the time is right.',
        ];

        let previousLine = null;
        for (let i = 0; i < embodimentLines.length; i++) {
          const lineText = embodimentLines[i];
          const line = document.createElement('div');
          line.className = 'intro-text-line';
          line.textContent = lineText;
          // Move first two lines: up 3px on desktop, up 20px on mobile
          const isMobile = window.innerWidth <= 768;
          const offset = i < 2 ? (isMobile ? -20 : -3) : 0;
          line.style.top = `calc(33% - 70px + ${60 + i * 40 + offset}px)`; // Start 60px below Einstein quote, moved up 70px for header
          introEmbodimentLines.appendChild(line);

          // Grey out the previous line BEFORE showing the next one
          if (previousLine) {
            previousLine.style.transition = 'opacity 500ms ease, color 500ms ease';
            previousLine.style.opacity = '0.6';
            previousLine.style.color = '#78716C';
            await new Promise((resolve) => setTimeout(resolve, 500)); // Wait for grey transition
          }

          await fadeInClean(line, 860);
          announceForScreenReader(lineText);
          await new Promise((resolve) => setTimeout(resolve, TIMING.lineDuration));

          // Check if animations were skipped during the wait
          if (skipIntroAnimations) {
            return; // Exit early if user clicked logo
          }

          previousLine = line;
        }

        // 4. Grey out the last embodiment line
        if (previousLine) {
          previousLine.style.transition = 'opacity 500ms ease, color 500ms ease';
          previousLine.style.opacity = '0.6';
          previousLine.style.color = '#78716C';
          await new Promise((resolve) => setTimeout(resolve, 500)); // Wait for grey transition
        }
        await new Promise((resolve) => setTimeout(resolve, TIMING.beforeOrientation));

        // 5. Show continue button
        await fadeIn(introContinueContainer, 800);
        console.log('Continue button visible, waiting for user action...');

        // Wait for user to click continue
        // The rest will be handled by the continue button click handler
      }

      // Handle Continue button click - show protocol list page
      async function showProtocolListPage() {
        console.log('Showing protocol list page...');

        // Scroll to top
        window.scrollTo(0, 0);

        // Fade out both the intro logo and content together (same duration)
        const introLogoContainer = document.querySelector('.intro-logo-container');
        await Promise.all([
          fadeOut(introContent, 800),
          introLogoContainer ? fadeOut(introLogoContainer, 800) : Promise.resolve(),
        ]);

        // Hide intro content
        introContent.style.display = 'none';

        // Hide the big intro logo
        if (introLogoContainer) {
          introLogoContainer.style.display = 'none';
        }

        // Show protocol list page
        introProtocolListPage.classList.add('visible');

        // Show header logo on protocol list page
        pageHeader.classList.add('protocol-list-active');

        // Skip sequence list - don't show it
        // await fadeIn(introSequenceContainer, 1000);
        // announceForScreenReader('Protocol sequence revealed: Field Diagnostic and 5 exit protocols');

        // Fade in guidance text and protocol cards together
        if (introProtocolGuidance) {
          // Force browser to render initial state before transition
          await new Promise((resolve) =>
            requestAnimationFrame(() => {
              requestAnimationFrame(resolve);
            })
          );

          introProtocolGuidance.classList.add('visible');
        }

        // Load and render protocol cards (happens during guidance fade)
        await loadAndRenderProtocolCards();
      }

      // Continue button click handler
      introContinueBtn.addEventListener('click', () => {
        showProtocolListPage();
      });

      // Keyboard shortcut: Cmd/Ctrl + Enter to skip intro
      document.addEventListener('keydown', (e) => {
        const modifier = isMac ? e.metaKey : e.ctrlKey;
        const isShortcut = modifier && e.key === 'Enter';

        if (isShortcut) {
          // Only trigger if continue button is visible and intro content is still showing
          if (
            introContinueContainer &&
            parseFloat(window.getComputedStyle(introContinueContainer).opacity) > 0.5 &&
            window.getComputedStyle(introContent).display !== 'none'
          ) {
            e.preventDefault();
            showProtocolListPage();
          }
        }
      });

      // Logo click handler - reveal all text instantly
      if (introLogo) {
        introLogo.addEventListener('click', () => {
          // Only trigger if intro content is showing and animations haven't been skipped
          if (!skipIntroAnimations && window.getComputedStyle(introContent).display !== 'none') {
            revealAllIntroText();
          }
        });
      }

      // Load protocols from API and render cards with progressive disclosure
      async function loadAndRenderProtocolCards() {
        try {
          const response = await fetch(`${API_BASE}/api/protocols`);
          const data = await response.json();

          if (data.protocols && data.protocols.length > 0) {
            // Sort: Field Diagnostic first, then the 5 Field Exit protocols in order
            const sortedProtocols = data.protocols
              .sort((a, b) => {
                if (a.slug === 'field_diagnostic') return -1;
                if (b.slug === 'field_diagnostic') return 1;
                // Extract number from field_exit_protocol_N_...
                const aNum = parseInt(a.slug.match(/field_exit_protocol_(\d+)/)?.[1] || '999');
                const bNum = parseInt(b.slug.match(/field_exit_protocol_(\d+)/)?.[1] || '999');
                return aNum - bNum;
              })
              .slice(0, 6); // Take only the first 6

            // Render each protocol card
            for (const protocol of sortedProtocols) {
              renderProtocolCard(protocol);
            }

            // Force browser to render initial state before transition
            await new Promise((resolve) =>
              requestAnimationFrame(() => {
                requestAnimationFrame(resolve);
              })
            );

            // Fade in the protocol deck
            introProtocolDeck.classList.add('visible');
            announceForScreenReader(
              'Protocol cards revealed. Use tab to navigate and explore each protocol.'
            );
          }
        } catch (error) {
          console.error('Error loading protocols for intro:', error);
        }
      }

      // Render a single protocol card with progressive disclosure
      function renderProtocolCard(protocol) {
        const card = document.createElement('div');
        card.className = 'intro-protocol-card';

        // Title
        const title = document.createElement('div');
        title.className = 'intro-protocol-title';
        title.textContent = protocol.title;
        card.appendChild(title);

        // Use When section (initially hidden)
        const useWhenSection = document.createElement('div');
        useWhenSection.className = 'intro-disclosure-section';

        // Format use_when as a list if it's an array, otherwise as plain text
        let useWhenContent = '';
        if (Array.isArray(protocol.use_when)) {
          useWhenContent =
            '<ul>' + protocol.use_when.map((item) => `<li>${item}</li>`).join('') + '</ul>';
        } else {
          useWhenContent = protocol.use_when || 'No use cases available';
        }

        useWhenSection.innerHTML = `
                <div class="intro-disclosure-label">Use This When</div>
                <div class="intro-disclosure-content">${useWhenContent}</div>
            `;
        card.appendChild(useWhenSection);

        // Use When button (initially visible)
        const useWhenBtn = document.createElement('button');
        useWhenBtn.className = 'intro-disclosure-btn';
        useWhenBtn.textContent = 'Use This When';
        useWhenBtn.setAttribute('aria-expanded', 'false');
        useWhenBtn.setAttribute('aria-controls', `usewhen-${protocol.id}`);
        useWhenSection.id = `usewhen-${protocol.id}`;
        card.appendChild(useWhenBtn);

        // Walk this Protocol button (initially hidden, shown after Use This When is clicked)
        const walkBtn = document.createElement('button');
        walkBtn.className = 'intro-walk-btn';
        walkBtn.textContent = 'Walk this Protocol';
        card.appendChild(walkBtn);

        // Handle Use This When button click
        useWhenBtn.addEventListener('click', () => {
          useWhenSection.classList.add('visible');
          useWhenBtn.style.display = 'none';
          useWhenBtn.setAttribute('aria-expanded', 'true');
          walkBtn.style.display = 'block';
          announceForScreenReader('Use This When revealed');
        });

        // Walk button handler - go to protocol entry view
        walkBtn.addEventListener('click', () => {
          console.log('ðŸŽ¯ Walk button clicked for protocol:', protocol.title);

          // Add dissolving class to trigger border fade
          walkBtn.classList.add('dissolving');

          // Wait for border to dissolve (1.5s) then navigate
          setTimeout(() => {
            console.log('ðŸš€ Navigating to entry view');

            // Scroll to top
            window.scrollTo(0, 0);

            // Set the selected protocol (needed for begin walk)
            selectProtocol(protocol);

            // Hide intro flow
            introFlowView.classList.add('hidden');
            console.log('âœ… Intro flow hidden');

            // Show content area
            const contentArea = document.querySelector('.content-area');
            if (contentArea) {
              contentArea.classList.add('visible');
              console.log('âœ… Content area visible');
            }

            // Remove intro-mode from header
            const pageHeader = document.getElementById('page-header');
            if (pageHeader) {
              pageHeader.classList.remove('intro-mode');
              console.log('âœ… Intro mode removed from header');
            }

            // Show entry view for this protocol
            protocolSelectionView.classList.add('hidden');
            entryView.classList.remove('hidden');
            console.log('âœ… Entry view shown, classes:', entryView.className);
            console.log('âœ… Entry view display:', window.getComputedStyle(entryView).display);
            console.log('âœ… Entry view children:', entryView.children.length);

            // Update header
            const headerTitle = document.querySelector('.header-title');
            if (headerTitle) {
              headerTitle.textContent = protocol.title;
            }

            // Focus the begin button
            if (beginButton) {
              beginButton.focus();
              console.log('âœ… Begin button focused');
            } else {
              console.error('âŒ Begin button not found!');
            }

            // Scroll to top
            window.scrollTo(0, 0);
          }, 1500);
        });

        introProtocolDeck.appendChild(card);
      }

      // Start the intro flow when page loads
      try {
        runIntroFlow().catch((error) => {
          console.error('Error in intro flow:', error);
        });
      } catch (error) {
        console.error('Error starting intro flow:', error);
      }

      // ========================================
      // MAIN APP LOGIC
      // ========================================

      // Cost tracking (rough estimate)
      let estimatedCost = 0;
      function updateCostDisplay(increment = 0.01) {
        estimatedCost += increment;
        costDisplay.textContent = `$${estimatedCost.toFixed(3)}`;
      }

      // Loading indicator helpers
      function showLoadingIndicator() {
        if (headerCenterLogo) {
          headerCenterLogo.classList.add('spinning');
        }
      }

      function hideLoadingIndicator() {
        if (headerCenterLogo) {
          headerCenterLogo.classList.remove('spinning');
        }
      }

      // Fetch and display available protocols
      async function loadProtocols() {
        try {
          const response = await fetch(`${API_BASE}/api/protocols`);
          const data = await response.json();

          if (data.protocols && data.protocols.length > 0) {
            renderProtocolCards(data.protocols);
          } else {
            showError('No protocols available');
          }
        } catch (error) {
          console.error('Error loading protocols:', error);
          showError('Failed to load protocols. Please refresh the page.');
        }
      }

      // Render protocol cards
      function renderProtocolCards(protocols) {
        protocolGrid.innerHTML = '';

        // Sort protocols: Field Diagnostic first, then alphabetically by title
        const sortedProtocols = [...protocols].sort((a, b) => {
          if (a.slug === 'field_diagnostic') return -1;
          if (b.slug === 'field_diagnostic') return 1;
          return a.title.localeCompare(b.title);
        });

        sortedProtocols.forEach((protocol) => {
          const card = document.createElement('div');
          card.className = 'protocol-card';

          // Truncate purpose if too long
          const purpose = protocol.purpose || 'No description available';
          const truncatedPurpose =
            purpose.length > 200 ? purpose.substring(0, 200) + '...' : purpose;

          card.innerHTML = `
                    <div class="protocol-card-header">
                        <div class="protocol-card-title">${protocol.title}</div>
                        <div class="protocol-card-badge">${protocol.theme_count} themes</div>
                    </div>
                    <div class="protocol-card-purpose">${truncatedPurpose}</div>
                `;

          card.addEventListener('click', () => selectProtocol(protocol));
          protocolGrid.appendChild(card);
        });
      }

      // Handle protocol selection
      function selectProtocol(protocol) {
        selectedProtocol = protocol;

        // Scroll to top
        window.scrollTo(0, 0);

        // Update protocol title in entry view with stacked format
        // Split title at em dash (â€”) or long dash if present
        const title = protocol.title;
        if (title.includes('â€”')) {
          const parts = title.split('â€”');
          protocolTitle.innerHTML = `${parts[0].trim()}<br>${parts[1].trim()}`;
        } else if (title.includes(' â€” ')) {
          const parts = title.split(' â€” ');
          protocolTitle.innerHTML = `${parts[0].trim()}<br>${parts[1].trim()}`;
        } else {
          protocolTitle.textContent = title;
        }

        // Hide protocol selection, show entry view
        protocolSelectionView.classList.add('hidden');
        entryView.classList.remove('hidden');
      }

      // Load protocols on page load
      loadProtocols();

      // Set helper text based on platform
      responseHint.textContent = isMac
        ? 'Press âŒ˜ + Enter to continue'
        : 'Press Ctrl + Enter to continue';

      // Update button aria-label for accessibility
      if (continueButton) {
        continueButton.setAttribute(
          'aria-label',
          isMac ? 'Continue (Cmd + Enter)' : 'Continue (Ctrl + Enter)'
        );
      }

      // Enable continue button when response has content
      responseInput.addEventListener('input', () => {
        continueButton.disabled = !responseInput.value.trim();
      });

      // Handle keyboard shortcuts for continue action
      responseInput.addEventListener('keydown', (e) => {
        const modifier = isMac ? e.metaKey : e.ctrlKey;

        // Cmd/Ctrl + Enter: trigger Continue or Ask Another Question
        if (modifier && e.key === 'Enter') {
          e.preventDefault();
          if (responseInput.value.trim()) {
            // Check if we're in completion options mode
            const askAnotherBtn = document.getElementById('ask-another-button');
            if (askAnotherBtn && !askAnotherBtn.disabled) {
              askAnotherBtn.click();
            } else if (!continueButton.disabled) {
              handleContinue();
            }
          }
        }
        // Shift + Enter: allow new line (default behavior)
        // Enter alone: allow new line (default behavior)
      });

      // Escape key: Exit walk and return to protocol selection
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          // Check if we're in a walk (walk-view is visible or entry-view is visible)
          const isInWalk =
            (walkView && walkView.style.display !== 'none') ||
            (entryView && !entryView.classList.contains('hidden'));

          if (isInWalk && confirm('Exit this protocol and return to protocol selection?')) {
            // Reset views
            if (walkView) walkView.style.display = 'none';
            if (entryView) entryView.classList.add('hidden');

            // Show protocol selection
            protocolSelectionView.classList.remove('hidden');

            // Reset inputs
            if (responseInput) responseInput.value = '';
            if (continueButton) continueButton.disabled = true;

            // Scroll to top
            window.scrollTo(0, 0);
          }
        }
      });

      // Begin walk
      beginButton.addEventListener('click', async () => {
        console.log('ðŸŽ¬ BEGIN WALK BUTTON CLICKED');
        console.log('ðŸ“‹ Selected protocol:', selectedProtocol);

        // Add clicked class to fade out border
        beginButton.classList.add('clicked');

        // Show loading indicator
        showLoadingIndicator();

        // Fade out main entry logo and title
        const title = entryView.querySelectorAll('div')[0];
        const logo = document.getElementById('lichen-logo');

        beginButton.disabled = true;

        // Fade out main logo and title
        if (logo) logo.classList.add('fade-out');
        if (title) title.classList.add('fade-out');

        // Wait for fade animations to complete
        await new Promise((resolve) => setTimeout(resolve, 1200));

        try {
          // NEW: Use non-AI endpoint to get protocol entry content
          const response = await fetch(
            `${API_BASE}/api/protocols/${selectedProtocol?.slug}/entry`,
            {
              method: 'GET',
              headers: getHeaders(),
            }
          );

          const data = await response.json();

          // No session created yet - will create when user starts walk
          sessionId = null;
          protocolData = data;

          // No AI cost for loading entry content
          // updateCostDisplay not called - stays at $0.00

          // Render protocol entry content (no AI, just markdown content)
          renderProtocolEntry(data);

          // Hide loading indicator
          hideLoadingIndicator();
        } catch (error) {
          showError('The field lost connection. Please try again.');
          beginButton.textContent = 'Begin walk';
          beginButton.disabled = false;
          hideLoadingIndicator();
        }
      });

      // Show completion options (two buttons)
      function showCompletionOptions() {
        const walkControl = document.getElementById('walk-control');

        // Clear existing buttons
        walkControl.innerHTML = '';

        // Create two buttons
        const askAnotherBtn = document.createElement('button');
        askAnotherBtn.className = 'walk-button';
        askAnotherBtn.textContent = 'Ask Another Question';
        askAnotherBtn.id = 'ask-another-button';
        askAnotherBtn.style.marginRight = '1rem';

        const completeWalkBtn = document.createElement('button');
        completeWalkBtn.className = 'walk-button';
        completeWalkBtn.textContent = 'Complete Walk & View Summary';
        completeWalkBtn.id = 'complete-walk-button';

        walkControl.appendChild(askAnotherBtn);
        walkControl.appendChild(completeWalkBtn);

        // Handle ask another question
        askAnotherBtn.addEventListener('click', async () => {
          const userResponse = responseInput.value.trim();
          if (!userResponse) return;

          askAnotherBtn.classList.add('clicked');
          askAnotherBtn.disabled = true;
          responseInput.blur();

          // Show loading indicator
          showLoadingIndicator();

          try {
            const response = await fetch(`${API_BASE}/api/walk/continue`, {
              method: 'POST',
              headers: getHeaders(),
              body: JSON.stringify({
                session_id: sessionId,
                user_response: userResponse,
              }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));

              // Check for API overload (529)
              if (response.status === 529 || errorData.error?.type === 'overloaded_error') {
                showError(
                  'The AI service is currently experiencing high demand. Please wait a moment and try again.'
                );
              } else {
                showError('The field lost connection. Please try again.');
              }

              askAnotherBtn.classList.remove('clicked');
              askAnotherBtn.disabled = false;
              hideLoadingIndicator();
              return;
            }

            const data = await response.json();
            protocolData = data;
            updateCostDisplay(0.02);
            responseInput.value = '';
            renderWalkState(data);

            // Hide loading indicator
            hideLoadingIndicator();
          } catch (error) {
            showError('The field lost connection. Please try again.');
            askAnotherBtn.classList.remove('clicked');
            askAnotherBtn.disabled = false;
            hideLoadingIndicator();
          }
        });

        // Handle complete walk
        completeWalkBtn.addEventListener('click', async () => {
          completeWalkBtn.classList.add('clicked');
          completeWalkBtn.disabled = true;

          // Show loading indicator
          showLoadingIndicator();

          try {
            const response = await fetch(`${API_BASE}/api/walk/complete`, {
              method: 'POST',
              headers: getHeaders(),
              body: JSON.stringify({
                session_id: sessionId,
                generate_summary: true,
              }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));

              // Check for API overload (529)
              if (response.status === 529 || errorData.error?.type === 'overloaded_error') {
                showError(
                  'The AI service is currently experiencing high demand. Please wait a moment and try again.'
                );
              } else {
                showError('The field lost connection. Please try again.');
              }

              completeWalkBtn.classList.remove('clicked');
              completeWalkBtn.disabled = false;
              hideLoadingIndicator();
              return;
            }

            const data = await response.json();
            protocolData = data;

            // Update cost display for completion
            updateCostDisplay(0.02);

            renderWalkState(data);

            // Hide loading indicator
            hideLoadingIndicator();
          } catch (error) {
            showError('The field lost connection. Please try again.');
            completeWalkBtn.classList.remove('clicked');
            completeWalkBtn.disabled = false;
            hideLoadingIndicator();
          }
        });
      }

      // Continue walk handler function
      async function handleContinue() {
        const userResponse = responseInput.value.trim();
        if (!userResponse || !sessionId) return;

        // Add clicked class to fade out border
        continueButton.classList.add('clicked');

        // Blur input to stop cursor blinking
        responseInput.blur();

        continueButton.disabled = true;

        // Show loading indicator
        showLoadingIndicator();

        try {
          const response = await fetch(`${API_BASE}/api/walk/continue`, {
            method: 'POST',
            headers: getHeaders(),
            body: JSON.stringify({
              session_id: sessionId,
              user_response: userResponse,
            }),
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));

            // Check for API overload (529)
            if (response.status === 529 || errorData.error?.type === 'overloaded_error') {
              showError(
                'The AI service is currently experiencing high demand. Please wait a moment and try again.'
              );
            } else {
              showError('The field lost connection. Please try again.');
            }

            continueButton.classList.remove('clicked');
            continueButton.disabled = false;
            hideLoadingIndicator();
            return;
          }

          const data = await response.json();
          protocolData = data;

          // Update cost display (WALK responses typically cost ~$0.015-0.025)
          updateCostDisplay(0.02);

          responseInput.value = '';
          renderWalkState(data);

          continueButton.classList.remove('clicked');
          continueButton.disabled = false;

          // Hide loading indicator
          hideLoadingIndicator();

          // Focus will be set in renderWalkState after animation
        } catch (error) {
          showError('The field lost connection. Please try again.');
          continueButton.classList.remove('clicked');
          continueButton.disabled = false;
          hideLoadingIndicator();
        }
      }

      // Continue walk
      continueButton.addEventListener('click', handleContinue);

      // Handle generate report button (dynamically created after Theme 5)
      // Use event delegation since button is created dynamically
      document.addEventListener('click', async (e) => {
        if (e.target && e.target.id === 'generate-report-button') {
          const button = e.target;

          // Add clicked class to fade out border
          button.classList.add('clicked');
          button.disabled = true;

          // Show loading indicator
          showLoadingIndicator();

          try {
            // Trigger CLOSE mode by sending "yes" to continue
            const response = await fetch(`${API_BASE}/api/walk/continue`, {
              method: 'POST',
              headers: getHeaders(),
              body: JSON.stringify({
                session_id: sessionId,
                user_response: 'generate field diagnosis',
              }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({}));

              // Check for API overload (529)
              if (response.status === 529 || errorData.error?.type === 'overloaded_error') {
                showError(
                  'The AI service is currently experiencing high demand. Please wait a moment and try again.'
                );
              } else {
                showError('The field lost connection. Please try again.');
              }

              button.classList.remove('clicked');
              button.disabled = false;
              hideLoadingIndicator();
              return;
            }

            const data = await response.json();
            protocolData = data;

            // Update cost display (CLOSE mode costs ~$0.015)
            updateCostDisplay(0.015);

            renderWalkState(data);

            // Hide loading indicator
            hideLoadingIndicator();
          } catch (error) {
            showError('The field lost connection. Please try again.');
            button.classList.remove('clicked');
            button.disabled = false;
            hideLoadingIndicator();
          }
        }
      });

      // Render walk state
      async function renderWalkState(data) {
        console.log('ðŸš€ renderWalkState called, mode:', data.mode);
        console.log('ðŸ“¦ Full data received:', JSON.stringify(data, null, 2));
        console.log('ðŸ“„ Composer output:', data.composer_output);
        console.log('ðŸ“ Composer output length:', data.composer_output?.length);

        // Scroll to top whenever rendering walk state
        window.scrollTo(0, 0);

        // In ENTRY mode, stay in entry view but show protocol introduction
        if (data.mode === 'ENTRY') {
          console.log('ðŸ“ ENTRY mode - showing protocol introduction');

          headerState.textContent = 'Protocol Introduction';
          renderEntryResponse(data);
          return;
        }

        console.log('ðŸŽ¬ Starting WALK mode transition');

        // Update page header
        headerState.textContent = data.mode;

        // Handle undefined theme values gracefully
        const themeNum = data.theme_number || 1;
        const totalThemes = data.total_themes || 5;
        themePosition.textContent = `Theme ${themeNum} of ${totalThemes}`;

        // Parse and render composer output (but keep hidden)
        renderComposerOutput(data.composer_output);

        // Render supports - DISABLED
        // renderSupports(data);

        // supportsStrip.classList.add('active');

        // Hide entry view and show walk view
        entryView.style.display = 'none';
        walkView.style.opacity = '0';
        walkView.style.display = 'block';

        // Force reflow to ensure transition works
        walkView.offsetHeight;

        // Fade in everything
        walkView.style.opacity = '1';
        // supportsStrip.style.opacity = '1';

        // Add fade-in class to walk view children
        const walkChildren = walkView.querySelectorAll('.output-container, .response-area');
        walkChildren.forEach((child) => {
          child.classList.add('fade-in-section');
        });

        // Apply jigsaw animation after fade-in is complete (skip for COMPLETE mode)
        if (data.mode !== 'COMPLETE') {
          setTimeout(() => {
            const contentElements = composerOutput.querySelectorAll(
              '.theme-title, .section-content'
            );
            contentElements.forEach((el) => {
              if (el.textContent.trim()) {
                animateTextReveal(el);
              }
            });
          }, 100);
        }

        // Focus the response input after content is visible
        setTimeout(() => {
          responseInput.focus({ preventScroll: true });
        }, 900);

        // Handle completion options (two buttons when final theme is complete)
        if (data.show_completion_options) {
          console.log('ðŸŽ¯ COMPLETION OPTIONS DETECTED - Showing two buttons');
          showCompletionOptions();
        }

        // Handle completion
        if (data.mode === 'COMPLETE') {
          console.log('ðŸŽ¯ COMPLETE MODE DETECTED - Starting completion handling');
          console.log('ðŸ“‹ Data received:', data);
          console.log('ðŸ“„ Composer output length:', data.composer_output?.length);
          console.log('ðŸ“„ Composer output preview:', data.composer_output?.substring(0, 200));

          headerState.textContent = `${data.protocol_name} Summary`;
          handleCompletion(data);
        }
      }

      // Animate text revealing randomly like a jigsaw puzzle
      function animateTextReveal(element, duration = 400) {
        const text = element.textContent;
        const words = text.split(/(\s+)/); // Split by whitespace but keep the spaces

        // Create spans for each word/space
        element.textContent = '';
        const spans = [];

        words.forEach((word) => {
          if (word.trim() === '') {
            // It's a space, add it directly
            element.appendChild(document.createTextNode(word));
          } else {
            // It's a word, wrap in span
            const span = document.createElement('span');
            span.textContent = word;
            span.style.opacity = '0';
            span.style.transition = 'opacity 0.2s ease-in';
            span.style.display = 'inline';
            element.appendChild(span);
            spans.push(span);
          }
        });

        // Create random order for revealing
        const indices = spans.map((_, i) => i);
        for (let i = indices.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [indices[i], indices[j]] = [indices[j], indices[i]];
        }

        // Reveal words/letters in random order
        const totalSteps = Math.ceil(spans.length * 1.5); // More steps for variation
        const interval = duration / totalSteps;

        let revealed = 0;
        for (let step = 0; step < totalSteps && revealed < spans.length; step++) {
          setTimeout(() => {
            if (revealed < spans.length) {
              // Randomly decide: reveal full word (50%) or break into letters (50%)
              if (Math.random() > 0.5) {
                // Reveal full word
                spans[indices[revealed]].style.opacity = '1';
                revealed++;
              } else {
                // Break word into letters and reveal in random order
                const span = spans[indices[revealed]];
                const word = span.textContent;
                const letters = word.split('');

                span.textContent = '';
                const letterSpans = letters.map((letter) => {
                  const letterSpan = document.createElement('span');
                  letterSpan.textContent = letter;
                  letterSpan.style.opacity = '0';
                  letterSpan.style.transition = 'opacity 0.1s ease-in';
                  letterSpan.style.display = 'inline';
                  span.appendChild(letterSpan);
                  return letterSpan;
                });

                span.style.opacity = '1';

                // Create random order for letters
                const letterIndices = letters.map((_, i) => i);
                for (let i = letterIndices.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [letterIndices[i], letterIndices[j]] = [letterIndices[j], letterIndices[i]];
                }

                // Reveal letters in random order
                letterIndices.forEach((letterIndex, i) => {
                  setTimeout(() => {
                    letterSpans[letterIndex].style.opacity = '1';
                  }, i * 40);
                });

                revealed++;
              }
            }
          }, step * interval);
        }
      }

      // Render protocol entry content (from non-AI endpoint)
      function renderProtocolEntry(data) {
        // Hide begin button
        beginButton.style.display = 'none';

        // Fade in header logo
        if (headerCenterLogo) headerCenterLogo.classList.add('visible');

        // Hide the large logo, keep only header logo
        const logo = entryView.querySelector('img');
        const protocolTitleEl = document.getElementById('protocol-title');
        if (logo) {
          logo.style.display = 'none';
        }
        if (protocolTitleEl) {
          protocolTitleEl.classList.remove('fade-out');
          protocolTitleEl.classList.add('fade-in-only');

          // Add hover effect listeners
          protocolTitleEl.addEventListener('mouseenter', () => {
            protocolTitleEl.style.color = '#57534E';
          });
          protocolTitleEl.addEventListener('mouseleave', () => {
            protocolTitleEl.style.color = '#78716C';
          });
        }

        // Create response area in entry view
        let entryResponseArea = document.getElementById('entry-response-area');
        if (!entryResponseArea) {
          entryResponseArea = document.createElement('div');
          entryResponseArea.id = 'entry-response-area';
          entryResponseArea.style.cssText = 'margin-top: 1rem; line-height: 1.7;';
        }

        const sectionData = data.entry_sections;
        const firstThemeTitle = data.theme_1.title;

        // Helper function to format section content
        function formatSectionContent(content) {
          // Split by double newlines to get paragraphs, then process each
          const paragraphs = content.split(/\n\s*\n/);
          let html = '';

          for (let paragraph of paragraphs) {
            const trimmed = paragraph.trim();
            if (!trimmed) continue;

            // Check if this is a list item block
            const lines = trimmed.split('\n');
            const isListBlock = lines.every((line) => {
              const l = line.trim();
              return l.startsWith('- ') || l.startsWith('â€¢ ') || !l;
            });

            if (isListBlock) {
              // Render list items individually
              for (let line of lines) {
                const l = line.trim();
                if (l && (l.startsWith('- ') || l.startsWith('â€¢ '))) {
                  html += `<div style="margin-left: 1.5rem; margin-bottom: 0.5rem; color: #292524;">${l}</div>`;
                }
              }
            } else {
              // Join lines into a single paragraph (removes mid-sentence line breaks)
              const joinedText = lines
                .map((l) => l.trim())
                .filter((l) => l)
                .join(' ');
              html += `<div style="margin-bottom: 1rem; color: #292524; font-size: 1.0625rem;">${joinedText}</div>`;
            }
          }
          return html;
        }

        // Show first section immediately
        if (sectionData.length > 0) {
          const firstSection = document.createElement('div');
          firstSection.className = 'fade-in-only';

          // Create title
          const titleDiv = document.createElement('div');
          titleDiv.style.cssText =
            'font-size: 0.8125rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #78716C; margin-bottom: 0.75rem;';
          titleDiv.textContent = sectionData[0].title;
          firstSection.appendChild(titleDiv);

          // Create content container
          const contentDiv = document.createElement('div');
          contentDiv.innerHTML = formatSectionContent(sectionData[0].content);

          // Hide all text content initially
          const textElements = contentDiv.querySelectorAll('div');
          textElements.forEach((el) => {
            el.style.opacity = '0';
          });

          firstSection.appendChild(contentDiv);
          entryResponseArea.appendChild(firstSection);

          // Apply jigsaw animation to all text in content immediately
          textElements.forEach((el) => {
            if (el.textContent.trim()) {
              el.style.opacity = '1';
              animateTextReveal(el);
            }
          });
        }

        // Create buttons for remaining sections
        let currentIndex = 1;

        function showNextSection(event) {
          if (currentIndex < sectionData.length) {
            const section = sectionData[currentIndex];

            // Fade out the box by adding class to the clicked button
            const button = event.target;
            if (button) {
              button.classList.add('revealed');

              // After transition, add content and next button
              setTimeout(() => {
                // Create content container
                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = formatSectionContent(section.content);

                // Hide all text content initially
                const textElements = contentDiv.querySelectorAll('div');
                textElements.forEach((el) => {
                  el.style.opacity = '0';
                });

                // Insert content after button
                button.after(contentDiv);

                // Apply jigsaw animation to all text in content immediately
                textElements.forEach((el) => {
                  if (el.textContent.trim()) {
                    el.style.opacity = '1';
                    animateTextReveal(el);
                  }
                });

                currentIndex++;

                // Add next button or continue button
                if (currentIndex < sectionData.length) {
                  addRevealButton(sectionData[currentIndex].title);
                } else {
                  addContinueButton();
                }
              }, 500);
            }
          }
        }

        function addRevealButton(nextTitle) {
          const btn = document.createElement('button');
          btn.className = 'section-reveal-btn fade-in-only section-reveal-button';
          btn.textContent = nextTitle;
          btn.onclick = showNextSection;

          entryResponseArea.appendChild(btn);
        }

        function addContinueButton() {
          const continueControl = document.createElement('div');
          continueControl.className = 'walk-control';
          continueControl.style.marginTop = '2rem';

          const continueBtn = document.createElement('button');
          continueBtn.className = 'walk-button fade-in-only';
          continueBtn.textContent = `Continue to Theme 1 â€“ ${firstThemeTitle}`;
          continueBtn.onclick = async () => {
            continueBtn.classList.add('clicked');
            continueBtn.disabled = true;

            // Show loading indicator
            showLoadingIndicator();

            try {
              // NOW create session and start WALK mode (first AI call)
              const response = await fetch(`${API_BASE}/api/walk/start`, {
                method: 'POST',
                headers: getHeaders(),
                body: JSON.stringify({
                  user_input: 'begin walk',
                  protocol_slug: selectedProtocol?.slug,
                  mode: 'WALK', // Skip ENTRY mode, go straight to WALK
                }),
              });

              const walkData = await response.json();
              sessionId = walkData.session_id;
              protocolData = walkData;

              // Update cost display (Theme 1 AI call typically costs ~$0.02)
              updateCostDisplay(0.02);

              renderWalkState(walkData);

              // Hide loading indicator
              hideLoadingIndicator();
            } catch (error) {
              showError('The field lost connection. Please try again.');
              continueBtn.classList.remove('clicked');
              continueBtn.disabled = false;
              hideLoadingIndicator();
            }
          };

          continueControl.appendChild(continueBtn);
          entryResponseArea.appendChild(continueControl);
        }

        // Add first section reveal button
        if (sectionData.length > 1) {
          addRevealButton(sectionData[1].title);
        } else {
          addContinueButton();
        }

        // Add click handler to protocol title to expand all sections at once
        if (protocolTitleEl) {
          protocolTitleEl.onclick = () => {
            // Only expand if there are hidden sections
            if (currentIndex < sectionData.length) {
              // Remove any existing reveal buttons
              const revealButtons = entryResponseArea.querySelectorAll('.section-reveal-btn');
              revealButtons.forEach((btn) => btn.remove());

              // Create a container for all sections to fade in together
              const allSectionsContainer = document.createElement('div');
              allSectionsContainer.style.cssText =
                'opacity: 0; transition: opacity 1s ease-in-out;';

              // Add all remaining sections
              for (let i = currentIndex; i < sectionData.length; i++) {
                const section = sectionData[i];

                const sectionDiv = document.createElement('div');
                sectionDiv.style.marginTop = '2rem';

                // Create title
                const titleDiv = document.createElement('div');
                titleDiv.style.cssText =
                  'font-size: 0.8125rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #78716C; margin-bottom: 0.75rem;';
                titleDiv.textContent = section.title;
                sectionDiv.appendChild(titleDiv);

                // Create content
                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = formatSectionContent(section.content);
                sectionDiv.appendChild(contentDiv);

                allSectionsContainer.appendChild(sectionDiv);
              }

              entryResponseArea.appendChild(allSectionsContainer);

              // Trigger fade in
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  allSectionsContainer.style.opacity = '1';
                });
              });

              // Update index and add continue button after animation
              setTimeout(() => {
                currentIndex = sectionData.length;
                addContinueButton();

                // Scroll to continue button
                const continueControl = entryResponseArea.querySelector('.walk-control');
                if (continueControl) {
                  continueControl.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
              }, 1000);
            }
          };
        }

        // Append response area to entry view
        entryView.appendChild(entryResponseArea);

        // Update header state
        headerState.textContent = 'Protocol Introduction';
      }

      // Render ENTRY mode response (protocol introduction)
      function renderEntryResponse(data) {
        // Hide begin button
        beginButton.style.display = 'none';

        // Fade in header logo when protocol introduction loads
        if (headerCenterLogo) headerCenterLogo.classList.add('visible');

        // Hide the large logo completely, keep only header logo
        const logo = entryView.querySelector('img');
        const protocolTitleEl = document.getElementById('protocol-title');
        if (logo) {
          logo.style.display = 'none';
        }
        if (protocolTitleEl) {
          protocolTitleEl.classList.remove('fade-out');
          protocolTitleEl.classList.add('fade-in-only');

          // Add hover effect listeners
          protocolTitleEl.addEventListener('mouseenter', () => {
            protocolTitleEl.style.color = '#57534E';
          });
          protocolTitleEl.addEventListener('mouseleave', () => {
            protocolTitleEl.style.color = '#78716C';
          });
        }

        // Create response area in entry view (only if it doesn't exist)
        let entryResponseArea = document.getElementById('entry-response-area');
        if (!entryResponseArea) {
          entryResponseArea = document.createElement('div');
          entryResponseArea.id = 'entry-response-area';
          entryResponseArea.style.cssText = 'margin-top: 1rem; line-height: 1.7;';
        }

        // Parse JSON response from agent
        let entryData;
        try {
          entryData = JSON.parse(data.composer_output);
        } catch (e) {
          console.error('Failed to parse ENTRY response JSON:', e);
          showError('Failed to load protocol content');
          return;
        }

        const sectionData = entryData.sections;
        const firstThemeTitle = entryData.firstThemeTitle;

        // Helper function to format section content
        function formatSectionContent(content) {
          // Split by double newlines to get paragraphs, then process each
          const paragraphs = content.split(/\n\s*\n/);
          let html = '';

          for (let paragraph of paragraphs) {
            const trimmed = paragraph.trim();
            if (!trimmed) continue;

            // Check if this is a list item block
            const lines = trimmed.split('\n');
            const isListBlock = lines.every((line) => {
              const l = line.trim();
              return l.startsWith('- ') || l.startsWith('â€¢ ') || !l;
            });

            if (isListBlock) {
              // Render list items individually
              for (let line of lines) {
                const l = line.trim();
                if (l && (l.startsWith('- ') || l.startsWith('â€¢ '))) {
                  html += `<div style="margin-left: 1.5rem; margin-bottom: 0.5rem; color: #292524;">${l}</div>`;
                }
              }
            } else {
              // Join lines into a single paragraph (removes mid-sentence line breaks)
              const joinedText = lines
                .map((l) => l.trim())
                .filter((l) => l)
                .join(' ');
              html += `<div style="margin-bottom: 1rem; color: #292524; font-size: 1.0625rem;">${joinedText}</div>`;
            }
          }
          return html;
        }

        // Show first section immediately
        if (sectionData.length > 0) {
          const firstSection = document.createElement('div');
          firstSection.className = 'fade-in-only';

          // Create title
          const titleDiv = document.createElement('div');
          titleDiv.style.cssText =
            'font-size: 0.8125rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #78716C; margin-bottom: 0.75rem;';
          titleDiv.textContent = sectionData[0].title;
          firstSection.appendChild(titleDiv);

          // Create content container
          const contentDiv = document.createElement('div');
          contentDiv.innerHTML = formatSectionContent(sectionData[0].content);

          // Hide all text content initially
          const textElements = contentDiv.querySelectorAll('div');
          textElements.forEach((el) => {
            el.style.opacity = '0';
          });

          firstSection.appendChild(contentDiv);
          entryResponseArea.appendChild(firstSection);

          // Apply jigsaw animation to all text in content immediately
          textElements.forEach((el) => {
            if (el.textContent.trim()) {
              el.style.opacity = '1';
              animateTextReveal(el);
            }
          });
        }

        // Create buttons for remaining sections
        let currentIndex = 1;

        function showNextSection(event) {
          if (currentIndex < sectionData.length) {
            const section = sectionData[currentIndex];

            // Fade out the box by adding class to the clicked button
            const button = event.target;
            if (button) {
              button.classList.add('revealed');

              // After transition, add content and next button
              setTimeout(() => {
                // Create content container
                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = formatSectionContent(section.content);

                // Hide all text content initially
                const textElements = contentDiv.querySelectorAll('div');
                textElements.forEach((el) => {
                  el.style.opacity = '0';
                });

                // Insert content after button
                button.after(contentDiv);

                // Apply jigsaw animation to all text in content immediately
                textElements.forEach((el) => {
                  if (el.textContent.trim()) {
                    el.style.opacity = '1';
                    animateTextReveal(el);
                  }
                });

                currentIndex++;

                // Add next button or continue button
                if (currentIndex < sectionData.length) {
                  addRevealButton(sectionData[currentIndex].title);
                } else {
                  addContinueButton();
                }
              }, 500);
            }
          }
        }

        function addRevealButton(nextTitle) {
          const btn = document.createElement('button');
          btn.className = 'section-reveal-btn fade-in-only section-reveal-button';
          btn.textContent = nextTitle;
          btn.onclick = showNextSection;

          entryResponseArea.appendChild(btn);
        }

        function addContinueButton() {
          const continueControl = document.createElement('div');
          continueControl.className = 'walk-control';
          continueControl.style.marginTop = '2rem';

          const continueBtn = document.createElement('button');
          continueBtn.className = 'walk-button fade-in-only';
          continueBtn.textContent = `Continue to Theme 1 â€“ ${firstThemeTitle}`;
          continueBtn.onclick = async () => {
            continueBtn.classList.add('clicked');
            continueBtn.disabled = true;

            // Show loading indicator
            showLoadingIndicator();

            try {
              const response = await fetch(`${API_BASE}/api/walk/continue`, {
                method: 'POST',
                headers: getHeaders(),
                body: JSON.stringify({
                  session_id: sessionId,
                  user_response: 'yes',
                }),
              });

              const data = await response.json();
              protocolData = data;

              // Update cost display (initial walk start typically costs ~$0.02)
              updateCostDisplay(0.02);

              renderWalkState(data);

              // Hide loading indicator
              hideLoadingIndicator();
            } catch (error) {
              showError('The field lost connection. Please try again.');
              continueBtn.classList.remove('clicked');
              continueBtn.disabled = false;
              hideLoadingIndicator();
            }
          };

          // Add "Return to Protocol Selection" button (top right)
          const backBtn = document.createElement('button');
          backBtn.className = 'fade-in-only';
          backBtn.style.cssText =
            'position: absolute; top: 1.5rem; right: 1.5rem; background: transparent; border: 1px solid #D6D3D1; color: #78716C; padding: 0.5rem 1rem; font-size: 0.875rem; border-radius: 9999px; cursor: pointer; transition: all 0.2s ease; font-family: inherit;';
          backBtn.textContent = 'Return to Protocol Selection';
          backBtn.onmouseenter = () => {
            backBtn.style.background = '#F5F5F4';
          };
          backBtn.onmouseleave = () => {
            backBtn.style.background = 'transparent';
          };
          backBtn.onclick = () => {
            // Hide entry view
            entryView.classList.add('hidden');
            // Show protocol selection
            protocolSelectionView.classList.remove('hidden');
            // Scroll to top
            window.scrollTo(0, 0);
            // Remove the button
            backBtn.remove();
          };

          // Append button to entry view (top right)
          entryView.appendChild(backBtn);

          continueControl.appendChild(continueBtn);
          entryResponseArea.appendChild(continueControl);
        }

        // Add first reveal button if there are more sections
        if (sectionData.length > 1) {
          addRevealButton(sectionData[1].title);
        } else {
          addContinueButton();
        }

        // Add click handler to protocol title to expand all sections at once
        if (protocolTitleEl) {
          protocolTitleEl.onclick = () => {
            // Only expand if there are hidden sections
            if (currentIndex < sectionData.length) {
              // Remove any existing reveal buttons
              const revealButtons = entryResponseArea.querySelectorAll('.section-reveal-btn');
              revealButtons.forEach((btn) => btn.remove());

              // Create a container for all sections to fade in together
              const allSectionsContainer = document.createElement('div');
              allSectionsContainer.style.cssText =
                'opacity: 0; transition: opacity 1s ease-in-out;';

              // Add all remaining sections
              for (let i = currentIndex; i < sectionData.length; i++) {
                const section = sectionData[i];
                const sectionDiv = document.createElement('div');
                sectionDiv.style.cssText = 'margin-top: 2rem;';

                // Create title
                const titleDiv = document.createElement('div');
                titleDiv.style.cssText =
                  'font-size: 0.8125rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; color: #78716C; margin-bottom: 0.75rem;';
                titleDiv.textContent = section.title;
                sectionDiv.appendChild(titleDiv);

                // Create content
                const contentDiv = document.createElement('div');
                contentDiv.innerHTML = formatSectionContent(section.content);
                sectionDiv.appendChild(contentDiv);

                allSectionsContainer.appendChild(sectionDiv);
              }

              // Add container to entry response area
              entryResponseArea.appendChild(allSectionsContainer);

              // Trigger fade-in animation
              setTimeout(() => {
                allSectionsContainer.style.opacity = '1';

                // Apply jigsaw animation to all text after fade-in starts
                setTimeout(() => {
                  const textElements = allSectionsContainer.querySelectorAll('div');
                  textElements.forEach((el) => {
                    if (el.textContent.trim() && !el.querySelector('div')) {
                      animateTextReveal(el);
                    }
                  });
                }, 300);
              }, 50);

              // Update current index to mark all as shown
              currentIndex = sectionData.length;

              // Add continue button
              setTimeout(() => {
                addContinueButton();
              }, 1100);

              // Remove click handler after use
              protocolTitleEl.onclick = null;
              protocolTitleEl.style.cursor = 'default';
              protocolTitleEl.removeAttribute('title');
            }
          };
        }

        // Add to entry view
        entryView.appendChild(entryResponseArea);
      }

      // Render composer output
      // Convert markdown to HTML with improved parsing
      function convertMarkdownToHTML(markdown) {
        if (!markdown) return '';

        console.log('ðŸ”§ MARKDOWN INPUT (first 500 chars):', markdown.substring(0, 500));

        let html = markdown;

        // Filter out horizontal rules (---) - they're structural markers, not content
        html = html.replace(/^---+\s*$/gm, '');

        // First, convert headers (before any other processing)
        // Support both ## and # formats
        html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
        html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
        html = html.replace(/^# (.+)$/gm, '<h2>$1</h2>');

        // Convert **bold text:** or **bold** to <strong>
        // Use a more robust pattern that handles multi-line and inline bold
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

        // Convert bullet points
        html = html.replace(/^\â€¢ (.+)$/gm, '<li>$1</li>');
        html = html.replace(/^- (.+)$/gm, '<li>$1</li>');

        // Wrap consecutive <li> tags in <ul>
        html = html.replace(/(<li>.*?<\/li>\n?)+/gs, (match) => {
          return '<ul>' + match + '</ul>';
        });

        // Split into paragraphs based on double newlines first
        const paragraphs = html.split(/\n\n+/);
        const processed = [];

        for (let para of paragraphs) {
          const trimmed = para.trim();
          if (!trimmed) continue;

          // Check if it's already an HTML element
          if (
            trimmed.startsWith('<h2>') ||
            trimmed.startsWith('<h3>') ||
            trimmed.startsWith('<ul>') ||
            trimmed.startsWith('<ol>') ||
            trimmed.startsWith('<li>')
          ) {
            processed.push(trimmed);
          } else {
            // Wrap plain text in paragraph tags
            // Replace single newlines with spaces within paragraphs
            const cleanText = trimmed.replace(/\n/g, ' ').replace(/\s+/g, ' ');
            processed.push('<p>' + cleanText + '</p>');
          }
        }

        const result = processed.join('\n\n');
        console.log('ðŸ”§ FINAL HTML (first 500 chars):', result.substring(0, 500));
        console.log('ðŸ”§ Total processed elements:', processed.length);

        return result;
      }

      function renderComposerOutput(markdown) {
        composerOutput.innerHTML = '';

        console.log('ðŸ“„ Composer output markdown:', markdown);

        // Parse markdown sections
        const sections = parseMarkdown(markdown);
        console.log('ðŸ“‹ Parsed sections:', sections);

        // Check if we should hide response area (protocol complete)
        const shouldHideResponseArea = sections.transition === 'PROTOCOL_COMPLETE';
        if (shouldHideResponseArea) {
          const responseArea = document.querySelector('.response-area');
          if (responseArea) responseArea.style.display = 'none';
          console.log('ðŸŽ¯ Hiding response area - protocol complete');
        } else {
          const responseArea = document.querySelector('.response-area');
          if (responseArea) responseArea.style.display = 'block';
        }

        // Render theme title if available
        if (sections.theme_name) {
          composerOutput.innerHTML += `
                    <div class="theme-title">${sections.theme_name}</div>
                `;
        }

        // Render based on available sections
        if (sections.orientation) {
          composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-label">Purpose</div>
                        <div class="section-content">${sections.orientation}</div>
                    </div>
                `;
        }

        if (sections.why_this_matters) {
          composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-label">Why This Theme Matters</div>
                        <div class="section-content">${sections.why_this_matters}</div>
                    </div>
                `;
        }

        if (sections.guiding_question) {
          const label = sections.guiding_question.includes('â€¢')
            ? 'Guiding Questions'
            : 'Guiding Question';
          const helperText =
            'Reflect on these questions as they relate to your current situation. Share what comes up for youâ€”there are no right or wrong answers.';
          composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-label">${label}</div>
                        <div class="section-content" style="font-size: 0.875rem; color: #78716C; margin-bottom: 0.75rem; font-style: italic;">${helperText}</div>
                        <div class="section-content" style="white-space: pre-line;">${sections.guiding_question}</div>
                    </div>
                `;
        }

        if (sections.instruction) {
          composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-content" style="color: #78716C; font-style: italic; margin-top: 1.5rem;">${sections.instruction}</div>
                    </div>
                `;
        }

        if (sections.acknowledgment) {
          // Convert markdown to HTML for better formatting
          const htmlContent = convertMarkdownToHTML(sections.acknowledgment);
          console.log('ðŸ“ SETTING innerHTML with htmlContent');
          console.log('ðŸ“ htmlContent length:', htmlContent.length);
          composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-content">${htmlContent}</div>
                    </div>
                `;
          console.log('ðŸ“ composerOutput.innerHTML length after:', composerOutput.innerHTML.length);
          console.log('ðŸ“ composerOutput classes:', composerOutput.className);
        }

        if (sections.completion_prompt) {
          const helperText = "When this statement feels true for you, you're ready to continue:";
          composerOutput.innerHTML += `
                    <div class="output-section">
                        <div class="section-label">Theme Completion</div>
                        <div class="section-content" style="font-size: 0.875rem; color: #78716C; margin-bottom: 0.5rem;">${helperText}</div>
                        <div class="section-content" style="font-style: italic; font-weight: 500; color: #57534E;">${sections.completion_prompt}</div>
                    </div>
                `;
        }

        if (sections.transition) {
          if (sections.transition === 'PROTOCOL_COMPLETE') {
            // Special case: Show "Generate Report" button after completing all themes
            const completionText =
              sections.completionText || 'You have completed all themes of this protocol.';
            composerOutput.innerHTML += `
                        <div class="output-section">
                            <div class="section-content" style="color: #78716C; font-size: 1rem;">${completionText}</div>
                        </div>
                        <div class="output-section" style="margin-top: 2rem;">
                            <button id="generate-report-button" class="walk-button">Field Diagnosis Complete, generate report</button>
                        </div>
                    `;
          } else {
            composerOutput.innerHTML += `
                        <div class="output-section">
                            <div class="section-content" style="color: #78716C; font-size: 1rem;">${sections.transition}</div>
                        </div>
                    `;
          }
        }
      }

      // Parse markdown into sections
      function parseMarkdown(markdown) {
        const sections = {};

        // Extract theme name from markdown (e.g., **Theme 1 â€“ Surface Behaviors**)
        const themeMatch = markdown.match(/\*\*(Theme\s+\d+\s*[â€“â€”:-]\s*[^*]+)\*\*/i);
        if (themeMatch) sections.theme_name = themeMatch[1].trim();

        // ENTRY mode sections
        const purposeMatch = markdown.match(/\*\*Purpose\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
        if (purposeMatch) sections.orientation = purposeMatch[1].trim();

        const outcomesMatch = markdown.match(
          /\*\*Protocol-Level Outcomes\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i
        );
        if (outcomesMatch) sections.guiding_question = outcomesMatch[1].trim();

        // WALK mode sections - Purpose/Frame is the orientation
        const purposeWalkMatch = markdown.match(/\*\*Purpose:\*\*\s*([\s\S]*?)(?=\n\*\*|$)/i);
        if (purposeWalkMatch) sections.orientation = purposeWalkMatch[1].trim();

        const frameMatch = markdown.match(/\*\*Frame:\*\*\s*([\s\S]*?)(?=\n\*\*|$)/i);
        if (frameMatch) sections.orientation = frameMatch[1].trim();

        const orientationMatch = markdown.match(/\*\*Orientation\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
        if (orientationMatch) sections.orientation = orientationMatch[1].trim();

        // Guiding Questions (plural) - extract the bullet points
        const questionsMatch = markdown.match(
          /\*\*Guiding Questions:\*\*\s*\n([\s\S]*?)(?=\n\n[^â€¢\n]|\n\*\*|$)/i
        );
        if (questionsMatch) {
          sections.guiding_question = questionsMatch[1].trim();
        }

        // Guiding Question (singular)
        const questionMatch = markdown.match(
          /\*\*Guiding Question\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i
        );
        if (questionMatch) sections.guiding_question = questionMatch[1].trim();

        // Common sections
        const whyMatch = markdown.match(/\*\*Why This Matters\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
        if (whyMatch) sections.why_this_matters = whyMatch[1].trim();

        // CLOSE mode - field diagnosis content
        // Check if this is completion content by looking for common CLOSE mode patterns
        // Updated to handle both Field Diagnostic and Field Exit protocols
        console.log('ðŸ” Checking if CLOSE mode...', {
          hasFieldCall: markdown.includes("field I'd call"),
          hasCompleted: markdown.includes("You've completed"),
          hasFieldDiagnosis: markdown.includes('**FIELD DIAGNOSIS**'),
          hasPattern: markdown.includes('**Pattern Identified:**'),
          hasType: markdown.includes('**Type:**'),
          hasPurposeColon: markdown.includes('Purpose:'),
          hasGuidingQuestions: markdown.includes('Guiding Questions:'),
          length: markdown.length,
          preview: markdown.substring(0, 200),
        });

        if (
          markdown.includes("field I'd call") ||
          markdown.includes("You've completed") ||
          markdown.includes('**FIELD DIAGNOSIS**') ||
          markdown.includes('**Pattern Identified:**') ||
          markdown.includes('**Type:**') ||
          markdown.includes('## Field Diagnosis') ||
          markdown.includes('## Evidence') ||
          markdown.includes('## Coherence Assessment') ||
          markdown.includes('## Close Mode Summary')
        ) {
          // For CLOSE mode, treat the entire content as acknowledgment/diagnosis
          console.log('âœ… CLOSE mode detected - treating as acknowledgment');
          sections.acknowledgment = markdown.trim();
          return sections;
        }

        console.log('ðŸ“ Not CLOSE mode - continuing to parse sections');

        // Interpretation section (with invisible marker like <!-- INTERPRETATION -->)
        const interpretationMatch = markdown.match(
          /<!--\s*INTERPRETATION\s*-->\s*\n([\s\S]*?)(?=\n(?:<!--|\*\*)|$)/i
        );
        if (interpretationMatch) {
          sections.acknowledgment = interpretationMatch[1].trim();
        }

        // Acknowledgment/Interpretation - fallback to capture from "I hear you" or "I see you" until completion prompt or transition
        if (!sections.acknowledgment) {
          const ackMatch = markdown.match(
            /^(I (?:hear|see) you[\s\S]*?)(?=\n\*\*Completion Prompt\*\*|Ready to move|Shall we move|\n\*\*Theme)/im
          );
          if (ackMatch) sections.acknowledgment = ackMatch[1].trim();
        }

        const promptMatch = markdown.match(/\*\*Completion Prompt\*\*\s*\n([\s\S]*?)(?=\n\*\*|$)/i);
        if (promptMatch) sections.completion_prompt = promptMatch[1].trim();

        // Check for protocol completion (any protocol, any number of themes)
        const completionMatch = markdown.match(/You've completed all \d+ themes of the .+/i);
        if (completionMatch) {
          sections.transition = 'PROTOCOL_COMPLETE';
          sections.completionText = completionMatch[0]; // Store the actual completion text
        } else {
          // Check for "Ready to move into Theme X" pattern
          const readyMatch = markdown.match(/Ready to move into \*\*(Theme \d+[^*]*)\*\*\??/i);
          if (readyMatch)
            sections.transition = `Ready to move into <strong>${readyMatch[1]}</strong>?`;

          // Check for "Shall we move into Theme X" pattern (older)
          const shallMatch = markdown.match(/Shall we move into \*\*(Theme \d+[^*]*)\*\*\??/i);
          if (shallMatch)
            sections.transition = `Shall we move into <strong>${shallMatch[1]}</strong>?`;
        }

        // Also check for "Would you like me to" pattern (ENTRY mode)
        const wouldYouMatch = markdown.match(/(Would you like me to.*?\*\*Theme \d+[^*]*\*\*\??)/i);
        if (wouldYouMatch) sections.transition = wouldYouMatch[1];

        // Extract final instruction like "Take a moment..."
        const instructionMatch = markdown.match(/\n\n([A-Z][^*\n]+(?:moment|ready)[^*\n]+\.)/);
        if (instructionMatch) sections.instruction = instructionMatch[1].trim();

        console.log('ðŸ“‹ Parsed sections:', {
          hasOrientation: !!sections.orientation,
          hasGuidingQuestion: !!sections.guiding_question,
          hasWhyThisMatters: !!sections.why_this_matters,
          hasAcknowledgment: !!sections.acknowledgment,
          hasTransition: !!sections.transition,
          guidingQuestionPreview: sections.guiding_question
            ? sections.guiding_question.substring(0, 100)
            : 'none',
        });

        return sections;
      }

      // Render supports - DISABLED
      /* function renderSupports(data) {
            supportsContainer.innerHTML = `<div class="supports-label">Supports (1)</div>`;

            const card = document.createElement('div');
            card.className = 'support-card';
            card.innerHTML = `
                <div class="support-header">
                    <div class="support-source">${data.protocol_name}</div>
                    <div class="support-theme">Theme ${data.theme_number}</div>
                </div>
                <div class="support-body">
                    <div class="support-content">${data.composer_output.substring(0, 300)}...</div>
                </div>
            `;

            card.addEventListener('click', () => {
                card.querySelector('.support-body').classList.toggle('expanded');
            });

            supportsContainer.appendChild(card);
        } */

      // Handle completion
      function handleCompletion(data) {
        console.log('ðŸ”§ handleCompletion called');
        console.log('ðŸ“‹ Data in handleCompletion:', data);

        // Add wider container class for summary mode
        const fieldContainer = document.getElementById('main-content');
        if (fieldContainer) {
          fieldContainer.classList.add('summary-container');
        }

        // Render the completion content (field diagnosis and summary)
        console.log('ðŸŽ¨ Rendering composer output...');
        renderComposerOutput(data.composer_output);

        // Add summary-mode class for enhanced styling
        console.log('ðŸ”§ Before adding summary-mode, classes:', composerOutput.className);
        composerOutput.classList.add('summary-mode');
        console.log('ðŸ”§ After adding summary-mode, classes:', composerOutput.className);

        // Log the actual HTML structure
        console.log(
          'ðŸ”§ Composer output HTML (first 500 chars):',
          composerOutput.innerHTML.substring(0, 500)
        );

        // Check if h2 tags exist
        const h2Tags = composerOutput.querySelectorAll('h2');
        console.log('ðŸ”§ Number of h2 tags found:', h2Tags.length);
        if (h2Tags.length > 0) {
          console.log('ðŸ”§ First h2 text:', h2Tags[0].textContent);
          console.log(
            'ðŸ”§ First h2 computed style font-size:',
            window.getComputedStyle(h2Tags[0]).fontSize
          );
          console.log(
            'ðŸ”§ First h2 computed style color:',
            window.getComputedStyle(h2Tags[0]).color
          );
        }

        console.log('âœ… Composer output rendered with summary styling');

        // Hide the entire response area (input + continue button)
        const responseArea = document.querySelector('.response-area');
        console.log('ðŸ” Response area found:', !!responseArea);
        if (responseArea) {
          console.log('ðŸ‘ï¸ Hiding response area');
          responseArea.style.display = 'none';
          console.log('âœ… Response area hidden');
        } else {
          console.log('âš ï¸ Response area not found!');
        }

        // Hide the existing continue button specifically
        const continueButton = document.getElementById('continue-button');
        console.log('ðŸ” Continue button found:', !!continueButton);
        if (continueButton) {
          console.log('ðŸ‘ï¸ Hiding continue button');
          continueButton.style.display = 'none';
          console.log('âœ… Continue button hidden');
        } else {
          console.log('âš ï¸ Continue button not found!');
        }

        // Add completion button container after composer output
        console.log('ðŸ”¨ Creating completion buttons...');
        const completionContainer = document.createElement('div');
        completionContainer.className = 'walk-control';
        completionContainer.style.marginTop = '3rem';
        completionContainer.style.display = 'flex';
        completionContainer.style.gap = '1rem';
        completionContainer.style.justifyContent = 'center';
        completionContainer.style.paddingTop = '2rem';
        completionContainer.style.borderTop = '1px solid #E7E5E4';
        completionContainer.innerHTML = `
                <button class="walk-button" id="download-button" style="padding: 0.875rem 1.75rem; font-size: 0.9375rem;">Download Summary</button>
                <button class="walk-button" id="completion-button" style="padding: 0.875rem 1.75rem; font-size: 0.9375rem;">Mark complete</button>
            `;

        // Insert completion button after composer output
        console.log('ðŸ” Composer output parent:', !!composerOutput.parentNode);
        composerOutput.parentNode.insertBefore(completionContainer, composerOutput.nextSibling);
        console.log('âœ… Completion buttons added');

        // Handle download button click
        const downloadButton = completionContainer.querySelector('#download-button');
        console.log('ðŸ” Download button found:', !!downloadButton);
        downloadButton.onclick = async () => {
          console.log('ðŸ–±ï¸ Download button clicked');

          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();

          const timestamp = new Date().toLocaleString();
          const pageWidth = doc.internal.pageSize.getWidth();
          const pageHeight = doc.internal.pageSize.getHeight();
          const margin = 20;
          const maxWidth = pageWidth - margin * 2;
          let yPosition = margin;

          // Load and add logo
          const logoImg = document.querySelector('img[src="/lichen-logo.png"]');
          if (logoImg) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = logoImg.width;
            canvas.height = logoImg.height;
            ctx.drawImage(logoImg, 0, 0);
            const logoData = canvas.toDataURL('image/png');

            // Add logo at top center (20mm wide, proportional height)
            const logoWidth = 20;
            const logoHeight = (logoImg.height / logoImg.width) * logoWidth;
            const logoX = (pageWidth - logoWidth) / 2;
            doc.addImage(logoData, 'PNG', logoX, yPosition, logoWidth, logoHeight);
            yPosition += logoHeight + 10;
          }

          // Helper function to add footer to each page
          const addFooter = () => {
            const currentDate = new Date().toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'long',
              day: 'numeric',
            });
            doc.setFontSize(8);
            doc.setFont('helvetica', 'normal');
            doc.setTextColor(160, 160, 160); // Subtle gray
            doc.text(currentDate, margin, pageHeight - 10);
            doc.setTextColor(0, 0, 0); // Reset to black
          };

          // Add footer to first page
          addFooter();

          // Helper function to add text with word wrapping
          const addText = (text, fontSize, isBold = false, isItalic = false) => {
            if (yPosition > pageHeight - 25) {
              doc.addPage();
              addFooter(); // Add footer to new page
              yPosition = margin;
            }

            doc.setFontSize(fontSize);
            if (isBold && isItalic) {
              doc.setFont('helvetica', 'bolditalic');
            } else if (isBold) {
              doc.setFont('helvetica', 'bold');
            } else if (isItalic) {
              doc.setFont('helvetica', 'italic');
            } else {
              doc.setFont('helvetica', 'normal');
            }

            const lines = doc.splitTextToSize(text, maxWidth);
            lines.forEach((line) => {
              if (yPosition > pageHeight - 25) {
                doc.addPage();
                addFooter(); // Add footer to new page
                yPosition = margin;
              }
              doc.text(line, margin, yPosition);
              yPosition += fontSize * 0.5;
            });
          };

          // Title
          addText(data.protocol_name.toUpperCase(), 18, true);
          yPosition += 5;
          addText('Summary Report', 14, false, true);
          yPosition += 10;

          // Draw a line
          doc.setDrawColor(200);
          doc.line(margin, yPosition, pageWidth - margin, yPosition);
          yPosition += 10;

          // Get the text content and parse it
          const summaryText = composerOutput.innerText || composerOutput.textContent;
          const lines = summaryText.split('\n');

          for (let line of lines) {
            const trimmed = line.trim();
            if (!trimmed) {
              yPosition += 3;
              continue;
            }

            // Check if it's a header (all caps or starts with specific patterns)
            if (
              trimmed.match(/^[A-Z\s]{5,}$/) ||
              trimmed.match(/^(FIELD DIAGNOSIS|SUMMARY|THE FIELD)/)
            ) {
              yPosition += 5;
              addText(trimmed, 14, true);
              yPosition += 5;
            } else if (trimmed.includes('**') || trimmed.match(/^[A-Z][A-Z\s]+:/)) {
              // Bold text or section headers
              const cleanText = trimmed.replace(/\*\*/g, '');
              addText(cleanText, 11, true);
              yPosition += 2;
            } else {
              // Regular paragraph text
              addText(trimmed, 10);
              yPosition += 2;
            }
          }

          // Save the PDF
          const protocolSlug = data.protocol_name
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-|-$/g, '');
          const date = new Date().toISOString().split('T')[0];
          doc.save(`${protocolSlug}-${date}.pdf`);

          console.log('âœ… Summary downloaded as PDF');
        };

        // Handle completion button click
        const button = completionContainer.querySelector('#completion-button');
        console.log('ðŸ” Completion button found:', !!button);
        button.onclick = async () => {
          console.log('ðŸ–±ï¸ Completion button clicked');

          // Add clicked class to fade out border
          button.classList.add('clicked');

          const overlay = document.getElementById('completion-overlay');
          overlay.classList.add('active');

          setTimeout(async () => {
            overlay.classList.remove('active');

            // Call complete endpoint
            await fetch(`${API_BASE}/api/walk/complete`, {
              method: 'POST',
              headers: getHeaders(),
              body: JSON.stringify({
                session_id: sessionId,
                generate_summary: false,
              }),
            });

            // Reset to entry
            location.reload();
          }, 4000);
        };

        console.log('ðŸŽ‰ handleCompletion completed');
      }

      // Show error
      function showError(message) {
        errorMessage.textContent = message;
        errorStrip.classList.add('active');
        setTimeout(() => errorStrip.classList.remove('active'), 5000);
      }
    </script>
  </body>
</html>
